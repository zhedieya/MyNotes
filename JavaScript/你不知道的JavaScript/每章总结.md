

### 第一部分 作用域和闭包

#### 第2章 词法作用域 

**词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编泽的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它**

**们进行查找。**

Javascript 中有两个机制可以 “欺骗”词法作用域：eval(…）和with。前者可以对一段包含一个或多个声明的 “代码”字符串进行演算，并借此来修改已经存在的词法作用

域（在运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。这

两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。

#### 第3章 函数作用域和块作用域

函数是 `Javaseript` 中最常见的作用城单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中 “隐藏”起来，这是有意为之的良好软件的设计原则。

但函数不是唯一的作用城单元。块作用域指的是变量和函数不仅可以属于所处的作用城，也可以属于某个代码块（通常指{…}的内部)。

从ES3 开始，`try/catch` 结构在 `catch` 分句中具有块作用域。

在ES6中引人了 `let` 关键字(`var` 关键字的表亲)，用来在任意代码块中声明变量。`if(..){let a = 2;}`会声明一个劫持了if的(..)块的变量，并且将变量添加到这个块

中。

有此人认为块作用城不应该完全作为函数作用域的替代方案。两种功能应该同时存在，开发者可以并且也应该根据需要选择使用何种作用域，创造可读、可维护的优良代码。

#### 第4章 提升

我们习惯将var a= 2；看作一个声明，而实际上JavaScript 引1擎并不这么认为。它将var a和a=2当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任

务。这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和的数）都会被“移动”到各自作用域的

最顶端，这个过程被称为提升。

声明本身会被提升，而包括函数表达式的赋值在内的操作并不会提升。

要注意避免重复声明，特别是当普通的var声明和函数声明混合在一起的时候，否则会引起很多危险的问题！

> 不过也有说法是存在三个阶段: 声明/创建 初始化 赋值
>
> 1. let 的「创建」过程被提升了，但是初始化没有提升。
> 2. var 的「创建」和「初始化」都被提升了。
> 3. function 的「创建」「初始化」和「赋值」都被提升了。



#### 第5章 作用域闭包

闭包就好像从 JavaScript 中分离出来的一个充满神秘色彩的未开化世界，只有最勇敢的人才能够到达那里。但实际上它只是一个普通且明显的事实，那就是我们在词法作用域的

环境下写代码，而其中的函数也是值，可以随意传来传去。

> **当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。**

如果没能认出闭包，也不了解它的工作原理，在使用它的过程甲就很容易犯错，比如在循环中。但同时闭包也是一个非常强大的工具，可以用多种形式来实现**模块**等模式：

模块有两个主要特征：（1）为创建内部作用域而调用了一个包装函数；（2） 包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包 装函数内部作用域

的闭包。

现在我们会发现代码中到处都有闭包存在，并且我们能够识别闭包然后用它来做一些有用的事！



#### 第6章 this全面解析

[this](/Users/owsl/Desktop/works/MyNotes/JavaScript/this.md)

1.函数是否在new中调用(new绑定)，如果是，那么this绑定的是新创建的对象。

2.函数是否通过call,apply调用，或者使用了bind(即硬绑定)，如果是，那么this绑定的就是指定的对象。

3.函数是否在某个上下文对象中调用(隐式绑定)，如果是的话，this绑定的是那个上下文对象。一般是obj.foo()

4.如果以上都不是，那么使用默认绑定。如果在严格模式下，则绑定到undefined，否则绑定到全局对象。

5.如果把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。

6.如果是箭头函数，箭头函数的this继承的是外层代码块的this。
