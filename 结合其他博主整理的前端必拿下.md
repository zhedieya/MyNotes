# 结合其他博主整理的前端必拿下

## CSS基础

### 两种盒模型

- 基本概念

	- 标准模型+IE模型，包括margin,border,padding,content

- 区别

	- IE盒模型的width/height = content + border + padding

	  如图

	- 标准盒模型的width/height = content

	  如图

- css如何改变盒模型

	- box-sizing

		- content-box(默认值): 标准盒模型

			- 宽度 = 内容的宽度
高度 = 内容的高度
不会包含border, padding。

		- border-box: 怪异模式

		  border-box的优势:
		  
		  border-box的诞生，主要就是解决content-box的最大缺点。border-box意味着子容器的padding和border的厚度都算在50%之内，这样，你可以随意的修改padding和border的厚度值，根本不用担心父容器被撑爆。
		  复制代码
		  简单修改下上述代码。
		  
		  .demo div {
		      box-sizing: border-box;
		      float: left;
		      width: 50%;
		      height: 100px;
		      padding: 0 10px;
		  }
		  复制代码
		  
		  因此border-box使用场景如下:
		  子元素有padding和border，或者至少有其一，并且需要给子元素设定100%宽度（或者50%宽度等等），这时候显然需要border-box。设为border-box之后，padding和border的厚度可以随意调，并不会溢出父元素。如果是content-box，那么，宽度必然会溢出，而且，为了不溢出，你设定子元素的宽度就只能是一个定值，或者是一个计算值（比如calc(100% - 20px)。

			- width = border + padding + 内容的width，
height = border + padding + 内容的height。

		- inherit: 规定应从父元素继承 box-sizing 属性的值

### 如何实现垂直居中(方案尽可能多)

- 定宽高

	- 绝对定位+负margin值

	  <template>
	    <div id="app">
	      <div class="box">
	        <div class="children-box"></div>
	      </div>
	    </div>
	  </template>
	  <style type="text/css">
	  .box {
	    width: 200px;
	    height: 200px;
	    border: 1px solid red;
	    position: relative;
	  }
	  .children-box {
	    position: absolute;
	    width: 100px;
	    height: 100px;
	    background: yellow;
	    left: 50%;
	    top: 50%;
	    margin-left: -50px;
	    margin-top: -50px; 
	  }
	  </style>

	- 绝对定位+transform

	  <template>
	    <div id="app">
	      <div class="box">
	        <div class="children-box"></div>
	      </div>
	    </div>
	  </template>
	  <style type="text/css">
	  .box {
	    width: 200px;
	    height: 200px;
	    border: 1px solid red;
	    position: relative;
	  }
	  .children-box {
	    position: absolute;
	    width: 100px;
	    height: 100px;
	    background: yellow;
	    left: 50%;
	    top: 50%;
	    transform: translate(-50%, -50%); 
	  }
	  </style>

	- 绝对定位+ left/right/bottom/top + margin

	  <template>
	    <div id="app">
	      <div class="box">
	        <div class="children-box"></div>
	      </div>
	    </div>
	  </template>
	  <style type="text/css">
	  .box {
	    width: 200px;
	    height: 200px;
	    border: 1px solid red;
	    position: relative;
	  }
	  .children-box {
	    position: absolute;
	    display: inline;
	    top: 0;
	    left: 0;
	    right: 0;
	    bottom: 0px;
	    background: yellow;
	    margin: auto;
	    height: 100px;
	    width: 100px;
	  }
	  </style>

	- flex布局

	  <template>
	    <div id="app">
	      <div class="box">
	        <div class="children-box"></div>
	      </div>
	    </div>
	  </template>
	  <style type="text/css">
	  .box {
	    width: 200px;
	    height: 200px;
	    border: 1px solid red;
	    display: flex;
	    justify-content: center;
	    align-items: center;
	  }
	  .children-box {
	    background: yellow;
	    height: 100px;
	    width: 100px;
	  }
	  </style>

	- grid布局

	  <template>
	    <div id="app">
	      <div class="box">
	        <div class="children-box"></div>
	      </div>
	    </div>
	  </template>
	  <style type="text/css">
	  .box {
	    width: 200px;
	    height: 200px;
	    border: 1px solid red;
	    display: grid;
	  }
	  .children-box {
	    width: 100px;
	    height: 100px;
	    background: yellow;
	    margin: auto;
	  }
	  </style>

	- table-cell + vertical-align + inline-block/margin: auto

	  <template>
	    <div id="app">
	      <div class="box">
	        <div class="children-box"></div>
	      </div>
	    </div>
	  </template>
	  <style type="text/css">
	  .box {
	    width: 200px;
	    height: 200px;
	    border: 1px solid red;
	    display: table-cell;
	    text-align: center;
	    vertical-align: middle;
	  }
	  .children-box {
	    width: 100px;
	    height: 100px;
	    background: yellow;
	    display: inline-block;// 可以换成margin: auto;
	  }
	  </style>

- 不定宽高

	- 绝对定位 + transform

	  <template>
	    <div id="app">
	      <div class="box">
	        <div class="children-box">111111</div>
	      </div>
	    </div>
	  </template>
	  <style type="text/css">
	  .box {
	    width: 200px;
	    height: 200px;
	    border: 1px solid red;
	    position: relative;
	  }
	  .children-box {
	    position: absolute;
	    background: yellow;
	    left: 50%;
	    top: 50%;
	    transform: translate(-50%, -50%);
	  }
	  </style>

	- table-cell + vertical-align + inline-block/margin: auto

	  <template>
	    <div id="app">
	      <div class="box">
	        <div class="children-box">111111</div>
	      </div>
	    </div>
	  </template>
	  <style type="text/css">
	  .box {
	    width: 200px;
	    height: 200px;
	    border: 1px solid red;
	    display: table-cell;
	    text-align: center;
	    vertical-align: middle;
	  }
	  .children-box {
	    background: yellow;
	    display: inline-block;
	  }
	  </style>

	- flex布局

	  <template>
	    <div id="app">
	      <div class="box">
	        <div class="children-box">11111111</div>
	      </div>
	    </div>
	  </template>
	  <style type="text/css">
	  .box {
	    width: 200px;
	    height: 200px;
	    border: 1px solid red;
	    display: flex;
	    justify-content: center;
	    align-items: center;
	  }
	  .children-box {
	    background: yellow;
	  }
	  </style>

	- flex变异布局

	  <template>
	    <div id="app">
	      <div class="box">
	        <div class="children-box">11111111</div>
	      </div>
	    </div>
	  </template>
	  <style type="text/css">
	  .box {
	    width: 200px;
	    height: 200px;
	    border: 1px solid red;
	    display: flex;
	  }
	  .children-box {
	    background: yellow;
	    margin: auto;
	  }
	  </style>

	- grid+flex布局

	  <template>
	    <div id="app">
	      <div class="box">
	        <div class="children-box">11111111</div>
	      </div>
	    </div>
	  </template>
	  <style type="text/css">
	  .box {
	    width: 200px;
	    height: 200px;
	    border: 1px solid red;
	    display: grid;
	  }
	  .children-box {
	    background: yellow;
	    align-self: center;
	    justify-self: center;
	  }
	  </style>

	- grid+margin布局

	  <template>
	    <div id="app">
	      <div class="box">
	        <div class="children-box">11111111</div>
	      </div>
	    </div>
	  </template>
	  <style type="text/css">
	  .box {
	    width: 200px;
	    height: 200px;
	    border: 1px solid red;
	    display: grid;
	  }
	  .children-box {
	    background: yellow;
	    margin: auto;
	  }
	  </style>

	- writing-mode属性布局

	  <template>
	    <div id="app">
	      <div class="box">
	        <div class="children-box">
	          <p>11111</p>
	        </div>
	      </div>
	    </div>
	  </template>
	  <style type="text/css">
	  .box {
	    width: 200px;
	    height: 200px;
	    border: 1px solid red;
	    writing-mode: vertical-lr;
	    text-align: center;
	  }
	  
	  .box>.children-box {
	    writing-mode: horizontal-tb;
	    display: inline-block;
	    text-align: center;
	    width: 100%;
	  }
	  
	  .box>.children-box>p {
	    display: inline-block;
	    margin: auto;
	    text-align: left;
	    background: yellow;
	  }
	  </style>

- 番外（图片定高、不定高水平垂直居中）

	- table-cell

	  <template>
	    <div id="app">
	      <div class="box">
	        <img src="https://ss1.baidu.com/70cFfyinKgQFm2e88IuM_a/forum/pic/item/242dd42a2834349b406751a3ceea15ce36d3beb6.jpg">
	      </div>
	      </div>
	  </template>
	  <style type="text/css">
	  .box {
	     height: 200px;
	    width: 200px;
	    display: table-cell;
	    text-align: center;
	    border: 1px solid #ccc;
	    vertical-align: middle;
	  }
	  </style>

	- ::after

	  <template>
	    <div id="app">
	      <div class="box">
	        <img src="https://ss1.baidu.com/70cFfyinKgQFm2e88IuM_a/forum/pic/item/242dd42a2834349b406751a3ceea15ce36d3beb6.jpg">
	      </div>
	    </div>
	  </template>
	  <style type="text/css">
	  .box {
	    width: 200px;
	    height: 200px;
	    border: 1px solid red;
	    text-align: center;
	  }
	  
	  .box::after {
	    content: '';
	    display: inline-block;
	    vertical-align: middle;
	    height: 100%;
	  }
	  img {
	    vertical-align: middle;
	  }
	  </style>

	- ::before

	  <template>
	    <div id="app">
	      <div class="box">
	        <img src="https://ss1.baidu.com/70cFfyinKgQFm2e88IuM_a/forum/pic/item/242dd42a2834349b406751a3ceea15ce36d3beb6.jpg">
	      </div>
	      </div>
	  </template>
	  <style type="text/css">
	  .box {
	    width: 200px;
	    height: 200px;
	    border: 1px solid #ccc;
	  
	    text-align: center;
	    font-size: 0;
	  }
	  
	  .box::before {
	    display: inline-block;
	    vertical-align: middle;
	    content: '';
	    height: 100%;
	  }
	  
	  img {
	    vertical-align: middle;
	  }
	  </style>

- 总结

	- 内联元素居中布局

	  水平居中
	  行内元素可设置：text-align: center;
	  flex布局设置父元素：display: flex; justify-content: center;
	  垂直居中
	  单行文本父元素确认高度：height === line-height
	  多行文本父元素确认高度：disaply: table-cell; vertical-align: middle;

	- 块级元素居中布局

	  水平居中
	  定宽: margin: 0 auto;
	  不定宽： 参考上诉例子中不定宽高例子。
	  垂直居中
	  position: absolute设置left、top、margin-left、margin-to(定高)；
	  position: fixed设置margin: auto(定高)；
	  display: table-cell；
	  transform: translate(x, y)；
	  flex(不定高，不定宽)；
	  grid(不定高，不定宽)，兼容性相对比较差；

### 移动端适配方案

- 使用 css 的媒体查询 @media

  基于 css 的媒体查询属性 @media 分别为不同屏幕尺寸的移动设备编写不同尺寸的 css 属性，示例如下所示。虽然此方法能在一定程度上解决移动设备适配的问题，但我们也可以看出其存在以下问题，所以其已几乎被历史潮流淘汰。
  
  页面上所有的元素都得在不同的 @media 中定义一遍不同的尺寸，这个代价有点高；
  如果再多一种屏幕尺寸，就得多写一个 @media 查询块；
  @media only screen and (min-width: 375px) {
    .logo {
      width : 62.5px;
    }
  }
  
  @media only screen and (min-width: 360px) {
    .logo {
      width : 60px;
    }
  }
  
  @media only screen and (min-width: 320px) {
    .logo {
      width : 53.3333px;
    }
  }

- 使用 rem 单位

  rem（font size of the root element）是指相对于根元素的字体大小的单位，如果我们设置 html 的 font-size 为 16px，则如果需要设置元素字体大小为 16px，则写为 1rem。但是其还是必须得借助 @media 属性来为不同大小的设备设置不同的 font-size，相对上一种方案，可以减少重复编写相同属性的代价，简单示例如下所示。
   我们也能看到该方案存在以下问题：
  不同的尺寸需要写多个 @media；
  所有涉及到使用 rem 的地方，全部都需要调用方法 calc() ，这个也挺麻烦的；
  @media only screen and (min-width: 375px) {
    html {
      font-size : 375px;
    }
  }
  
  @media only screen and (min-width: 360px) {
    html {
      font-size : 360px;
    }
  }
  
  @media only screen and (min-width: 320px) {
    html {
      font-size : 320px;
    }
  }
  
  //定义方法：calc
  @function calc($val){
      @return $val / 1080;
  }
  
  .logo{
  	width : calc(180rem);
  }

- flexible 适配方案

  在 rem 方案上进行改进，我们可以使用 js 动态来设置根字体，这种方案的典型代表就是 flexible 适配方案。

	- 使用 rem 模拟 vw 特性适配多种屏幕尺寸

	  它的核心代码如下所示
	  
	  // set 1rem = viewWidth / 10
	  function setRemUnit () {
	      var rem = docEl.clientWidth / 10
	      docEl.style.fontSize = rem + 'px'
	  }
	  setRemUnit();
	  复制代码
	  上面的代码中，将 html 节点的 font-size 设置为页面 clientWidth(布局视口)的 1/10，即 1rem 就等于页面布局视口的 1/10，这就意味着我们后面使用的 rem 都是按照页面比例来计算的。

	- 控制 viewport 的 width 和 scale 值适配高倍屏显示

	  设置 viewport 的 width 为 device-width，改变浏览器 viewport（布局视口和视觉视口）的默认宽度为理想视口宽度，从而使得用户可以在理想视口内看到完整的布局视口的内容。
	   等比设置 viewport 的 initial-scale、maximum-scale、minimum-scale 的值，从而实现 1 物理像素=1 css像素，以适配高倍屏的显示效果（就是在这个地方规避了大家熟知的“1px 问题”）
	  var metaEL= doc.querySelector('meta[name="viewport"]');
	  var dpr = window.devicePixelRatio;
	  var scale = 1 / dpr
	  metaEl.setAttribute('content', 'width=device-width, initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no');

	- flexible 的缺陷

	  不可否认 flexible 在兼容性不友好的某个时期还是极大帮助来成千上万的开发者，但是该方案自身是存在一些问题的。
	  
	  由于其缩放的缘故，video 标签的视频频播放器的样式在不同 dpr 的设备上展示差异很大；
	  如果你去研究过 lib-flexible 的源码，那你一定知道 lib-flexible 对安卓手机的特殊处理，即：一律按 dpr = 1 处理；
	  if (isIPhone) {
	    // iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案
	    if (devicePixelRatio >= 3 && (!dpr || dpr >= 3)) {                
	      dpr = 3;
	    } else if (devicePixelRatio >= 2 && (!dpr || dpr >= 2)){
	      dpr = 2;
	    } else {
	      dpr = 1;
	    }
	  } else {
	    // 其他设备下，仍旧使用1倍的方案
	    dpr = 1;
	  }
	  复制代码
	  不再兼容 @media 的响应式布局，因为 @media 语法中涉及到的尺寸查询语句，查询的尺寸依据是当前设备的物理像素，和 flexible 的布局理论（即针对不同 dpr 设备等比缩放视口的 scale 值，从而同时改变布局视口和视觉视口大小）相悖，因此响应式布局在“等比缩放视口大小”的情境下是无法正常工作的；
	  其实 flexible 方案是在 模拟 viewport 功能，只是随着浏览器的发展及兼容性增强，viewport 已经能兼容绝大部分主流浏览器，并且 flexible 方案自身存在的问题，所有其也已几乎退出历史潮流。引用 lib-flexible 的 github 主页的原话：
	  由于 viewport 单位得到众多浏览器的兼容，lib-flexible 这个过渡方案已经可以放弃使用，不管是现在的版本还是以前的版本，都存有一定的问题。建议大家开始使用 viewport 来替代此方案。

- viewport 适配方案

  由于 viewport 单位得到众多浏览器的兼容，所以目前基于 viewport 的移动端适配方案被各大厂团队所采用。
  vw 作为布局单位，从底层根本上解决了不同尺寸屏幕的适配问题，因为每个屏幕的百分比是固定的、可预测、可控制的。 viewport 相关概念如下：
  
  vw：是 viewport's width 的简写，1vw 等于 window.innerWidth 的 1%；
  vh：和 vw 类似，是 viewport's height 的简写，1vh 等于 window.innerHeihgt 的 1%；
  vmin：vmin 的值是当前 vw 和 vh 中较小的值；
  vmax：vmax 的值是当前 vw 和 vh 中较大的值；
  假设我们拿到的视觉稿宽度为 750px，视觉稿中某个字体大小为 75px，则我们的 css 属性只要如下这么写，不需要额外的去用 js 进行设置，也不需要去缩放屏幕等；
  
  .logo {
    font-size: 10vw; // 1vw = 750px * 1% = 7.5px
  }

	- 设置 meta 标签

	  在 html 头部设置 mata 标签如下所示，让当前 viewport 的宽度等于设备的宽度，同时不允许用户手动缩放。
	  
	  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">

	- px 自动转换为 vw

	  设计师一般给宽度大小为 375px 或 750px 的视觉稿，我们采用 vw 方案的话，需要将对应的元素大小单位 px 转换为 vw 单位，这是一项影响开发效率（需要手动计算将 px 转换为 vw）且不利于后续代码维护（css 代码中一堆 vw 单位，不如 px 看的直观）的事情；好在社区提供了 postcss-px-to-viewport 插件，来将 px 自动转换为 vw，相关配置步骤如下：
	  （1） 安装插件
	  
	  npm install postcss-px-to-viewport --save-dev
	  复制代码
	  （2）webpack 配置
	  官网是使用 glup 进行配置，但是我们项目模版中是使用 webpack 进行 postcss 插件以及相关样式插件的配置，所以我们就使用 webpack 进行配置使用，不需要额外引入 gulp 编译；webpack 相关配置如下，且每个属性表示的意义进行了备注：
	  
	  module.exports = {
	    plugins: {
	      // ...
	      'postcss-px-to-viewport': {
	        // options
	        unitToConvert: 'px',    // 需要转换的单位，默认为"px"
	        viewportWidth: 750,     // 设计稿的视窗宽度
	        unitPrecision: 5,       // 单位转换后保留的精度
	        propList: ['*', '!font-size'],        // 能转化为 vw 的属性列表
	        viewportUnit: 'vw',     // 希望使用的视窗单位
	        fontViewportUnit: 'vw', // 字体使用的视窗单位
	        selectorBlackList: [],  // 需要忽略的 CSS 选择器，不会转为视窗单位，使用原有的 px 等单位
	        minPixelValue: 1,       // 设置最小的转换数值，如果为 1 的话，只有大于 1 的值会被转换
	        mediaQuery: false,      // 媒体查询里的单位是否需要转换单位
	        replace: true,          // 是否直接更换属性值，而不添加备用属性
	        exclude: undefined,     // 忽略某些文件夹下的文件或特定文件，例如 'node_modules' 下的文件
	        include: /\/src\//,     // 如果设置了include，那将只有匹配到的文件才会被转换
	        landscape: false,       // 是否添加根据 landscapeWidth 生成的媒体查询条件
	        landscapeUnit: 'vw',    // 横屏时使用的单位
	        landscapeWidth: 1125,   // 横屏时使用的视窗宽度
	      },
	    },
	  };
	  复制代码
	  相关配置属性，通过注释一目了然其作用，其中需要强调的点为 propList 属性，我们配置了 font-size 不进行转换 vw，也就是说在不同手机屏幕尺寸下的字体大小是一样的。 其中 font-size 是否需要根据屏幕大小做适配，或者怎么做，一直是个争论不休的话题；考虑到我们移动端没有平板的需求，且咨询过团队业务设计师的意见，所以对模版进行以上默认配置；当然如果你的视觉要求你的项目要做字体大小适配，修改 propList 属性的配置即可。
	  （3）效果展示 我们在项目代码中，进行如下 css 编码：
	  
	  .hello {
	    color: #333;
	    font-size: 28px;
	  }
	  复制代码
	  启动项目，我们可以看到浏览器渲染的页面中，postcss-px-to-viewport 已经帮我们做进行了 px -> vw 的转换；如下所示：

	- 标注不需要转换的属性

	  在项目中，如果设计师要求某一场景不做自适配，需为固定的宽高或大小，这时我们就需要利用 postcss-px-to-viewport 插件的 Ignoring 特性，对不需要转换的 css 属性进行标注，示例如下所示：
	  
	  /* px-to-viewport-ignore-next */ —> 下一行不进行转换.
	  /* px-to-viewport-ignore */ —> 当前行不进行转换
	  /* example input: */
	  .class {
	    /* px-to-viewport-ignore-next */
	    width: 10px;
	    padding: 10px;
	    height: 10px; /* px-to-viewport-ignore */
	  }
	  
	  /* example output: */
	  .class {
	    width: 10px; 
	    padding: 3.125vw;
	    height: 10px;
	  }

	- Retina 屏预留坑位

- 设置视窗的宽度等于设计稿宽度，然后计算出设计稿宽度和实际设备显示宽度的比例，之后对scale属性进行设置使其实际显示宽度等于设备显示宽度，也可以做到适配

### 伪类与伪元素的区别

伪元素在CSS3之前就已经存在，只是没有伪元素的说法，都是归纳为伪类，所有很多人分不清楚伪类和伪元素。比如常用的:before和:after，它们是伪类还是伪元素？其实在CSS3之前被称为伪类，直到CSS3才正式区分出来叫伪元素

- 伪元素表示的是被选择元素的某个部分，这个部分看起来像一个独立的元素，但是是假原宿只存在于css中，所以叫伪的元素，例如:before和:after

  伪元素

- 伪类表示被选择元素的某种状态，例如:hover

  伪类

### 行内元素和块级元素

- 行内元素

  一个行内元素只占据它对应标签的边框所包含的空间。
      display:inline/inline-block 的元素
  <span> <a> <lable> <strong> <b> <small> <abbr> <button> <input> <textarea> <select> <code> <img> <br> <q> <i> <cite> <var> <kbd> <sub> <bdo>

- 块级元素

  块级元素占据其父元素（容器）的整个空间，因此创建了一个“块”。
  display:block/table 的元素
  <div> <p> <li> <h1> <h2> <h3> <h4> <h5> <h6> <form> <header> <hr> <ol> <address> <article> <aside> <audio> <canvas> <dd> <dl> <fieldset> <section> <ul> <video>

- 区别

	- 默认情况下，行内元素不会以新的一行开始，而块级元素会新起一行。

	  这个我们在定义那里就已经实践看过了。
	  比如我们增多几个标签，
	  
	  <span style="background-color: #1e7e34">行内元素</span>
	  <span style="background-color: #1e7e34">行内元素</span>
	  <span style="background-color: #1e7e34">行内元素</span>
	  <div style="background-color: #bbb">块级元素</div>
	  <div style="background-color: #bbb">块级元素</div>
	  <div style="background-color: #bbb">块级元素</div>
	  复制代码
	  
	  链接：https://juejin.cn/post/6964644611822190622
	  来源：稀土掘金
	  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

	- 块级元素可以设置 width, height属性，注意：块级元素即使设置了宽度，仍然是独占一行的。
而行内元素设置width, height无效。

	  <span style="background-color: #1e7e34;width: 200px;height: 100px;">行内元素</span>
	  <span style="background-color: #1e7e34;width: 200px;height: 100px;">行内元素</span>
	  <div style="background-color: #bbb;width: 200px;height: 100px;">块级元素</div>
	  <div style="background-color: #bbb;width: 200px;height: 100px;">块级元素</div>
	  复制代码

	- 块级元素可以设置margin 和 padding。
行内元素的水平方向的padding-left,padding-right,margin-left,margin-right 都产生边距效果，但是竖直方向的padding-top,padding-bottom,margin-top,margin-bottom都不会产生边距效果。（也就是水平方向有效，竖直方向无效）

	  <span style="background-color: #1e7e34;padding-top: 20px;">行内元素</span>
	  <div style="background-color: #bbb;padding-top: 20px;">块级元素</div>
	  复制代码
	  效果：
	  
	  剩下的属性自己试一试就能看出来了，这里就不多做演示。

	- 块级元素可以包含行内元素和块级元素。行内元素不能包含块级元素

	  比如我们想在<span>标签内包含<div>标签是不被允许的。而在<div>标签中包含<span>标签是经常看到的。

	- 块级元素 其宽度会自动填满父元素宽度，内联元素 其宽度随元素的内容变化
	- 设置居中

	  行内元素想要设置水平居中，只需要text-align属性即可。 这里设置的text-align是设置在外层的div当中，评论区有提到，因为上面讲了行内元素设置宽高是无效的，所以我们需要的居中其实是将块级元素当中的行内元素居中。
	  
	  div{
	      text-align:center  /*div当中的行内元素均会水平居中*/ 
	  }
	  
	  复制代码
	  而块级元素想要设置水平居中，需要设置宽度为父容器宽度才能居中。
	  
	  margin:0 auto; 
	  width:500px; /*块级元素父容器的宽度*/ 
	  复制代码
	  行内元素设置垂直居中，设置外层行高为行内元素的高度即可。
	  
	  height:30px; 
	  line-height:30px 
	  复制代码
	  而块级元素想要设置垂直居中，要先设置外层div的宽度，然后设置内层块级元素的样式。
	  
	  margin:0 aut0;
	  height:30px;
	  line-height:30px

### BFC

- 概念
- 原理

	- BFC元素垂直方向边距发生重叠，属于不同BFC外边距不会发生重叠
	- BFC元素不会与浮动元素的布局重叠
	- BFC元素是一个独立的容器，外面的元素不会影响里面的元素，里面的也不会影响外面的
	- 计算BFC高度的时候，浮动元素也会参与计算（清除浮动）

- 如何创建BFC

	- 1.overflow不为visible
	- 2.float值不为none
	- 3.position值不为static或者relative
	- 4.display属性为inline-blocks,table,table-cell,table-caption,flex,inline-flex

### 选择器优先级

CSS选择器优先级是指在给CSS元素设置样式的时候，如果同时有多个CSS选择器同时指向一个元素，那么优先级高的选择器的元素样式会最终应用到这个元素上。

CSS选择器类型
样式类型
行内样式：<style></style>
内联样式：<div style="color:red;">
外部样式：<link>或@import引入
选择器类型
id选择器、class选择器、属性选择器、*、伪类选择器、伪元素、后代选择器、子类选择器、兄弟选择器

权重计算规则
第一优先级：!important会覆盖页面内任何位置的元素样式
1.内联样式，如style="color: green"，权值为1000
2.ID选择器，如#app，权值为0100
3.类、伪类、属性选择器，如.foo, :first-child, div[class="foo"]，权值为0010
4.标签、伪元素选择器，如div::first-line，权值为0001
5.通配符、子类选择器、兄弟选择器，如*, >, +，权值为0000
6.继承的样式没有权值
比较规则
1.1000 > 0100，从左向右逐个比较，前一级相等才能往后比较
2.无论是行内样式、内部样式还是外部样式，都是按照以上提到的权重方式进行比较，面试的时候遇到优先级比较，答案往往是：行内>id>class>元素(标签)，我们以为给了能令面试官满意的答案，其实不然，比如对同一个元素操作，在权重相等的情况下，后面的样式会覆盖前面的，这样我们给出来的答案就不成立了
3.权重相同的情况下，位于后面的样式会覆盖前面的样式
4.通配符、子选择器、兄弟选择器，虽然权重为0000，但是优先于继承的样式
p {color: yellowgreen} /* 0,0,0,1 */
.para {color: red} /* 0,0,1,0 */
.inner p {color: pink} /* 0,0,1,1 */
.main p[class*="para"] {color: rgb(0, 255, 115)} /* 0,0,2,0 */ /*权重相同，后者覆盖前者*/
.main p[class="para1"] {color:teal} /* 0,0,2,0 */
div.main p[class="para2"]{color: blueviolet;} /* 0,0,2,1 */
.inner p:nth-child(4) {color: cornflowerblue !important;} /*0,0,2,0, !important提升优先级*/
复制代码
样式呈现的效果如下：

完整代码如下：

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            padding: 0;
            margin: 0;
            font-size: 24px;
        }
        .main {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        p {color: yellowgreen} /* 0,0,0,1 */
        .para {color: red} /* 0,0,1,0 */
        .inner p {color: pink} /* 0,0,1,1 */
        .main p[class*="para"] {color: rgb(0, 255, 115)} /* 0,0,2,0 */ /*权重相同，后者覆盖前者*/
        .main p[class="para1"] {color:teal} /* 0,0,2,0 */
        div.main p[class="para2"]{color: blueviolet;} /* 0,0,2,1 */
        .inner p:nth-child(4) {color: cornflowerblue !important;} /*0,0,2,0, !important提升优先级*/
    </style>
</head>
<body>
    <div class="main">
        <div id="app" class="inner" >
            <p style="color: red;">我是红色的，内联样式生效</p>
            <p class="para1">离离原上草，</p>
            <p class="para2">一岁一枯荣。</p>
            <p class="para3">野火烧不尽，</p>
            <p class="para4">春风吹又生。</p>
        </div>
    </div>
</body>
</html>

### position的值有哪些，区别是什么

### animation的参数，怎样实现一个动画

- 详情见CSS 动画 使元素逐渐从一种样式变为另一种样式.xmind

### css设置元素隐藏，两种有什么区别？

- display:none

	- 导致回流，包括位置的整个不见

- visibility:hidden

	- 导致重绘，位置还在元素不见

### css新特性

### CSS继承

- 可继承

	- 文字系列

		- font、font-family、font-weight、font-size、font-style;

	- 文本系列

		- 内联元素：color、line-height、word-spacing、letter-spacing、 text-transform;
		- 块级元素：text-indent、text-align;

	- 元素可见性

		- visibility

	- 表格布局属性

		- caption-side、border-collapse、border-spacing、empty-cells、 table-layout;

	- 列表布局属性

		- list-style

- 不可继承

	- display

		- 规定元素应该生成的框的类型；

	- 文本属性

		- vertical-align、text-decoration

	- 盒子模型属性

		- width、height、margin 、border、padding;

	- 背景属性

		- background、background-color、background-image;

	- 定位属性

		- float、clear、position、top、right、bottom、left、min-width、 min-height、max-width、max-height、overflow、clip

### css有哪些单位

- 绝对长度

	- px

	  绝对长度
	  px
	  px是像素值，是一个固定的长度，比如我们的米，厘米一样。

- 相对长度

	- em

	  em 与 px 的计算关系
	  em的值是px的倍数
	  默认情况下font-size = 16px,那么1em = 16px
	  
	  em 如何修改与px的相对计算关系
	  我们可以在自己元素上面修改font-size : 32px， 从而1em = 32px
	  如果自己元素上面没有设置font-size, 我们也可以在父元素上面设置font-size，从而来影响自己元素（孩子元素）使用的em的值。

	- rem

	  rem
	  rem 与 px 的计算关系
	  rem的值是px的倍数
	  默认情况下font-size = 16px,那么1rem = 16px
	  
	  rem 如何修改与px的相对计算关系
	  我们可以在并且只能在html标签（因为html节点是根节点，就是rem里面的r：root）里面修改font-size : 32px， 从而1rem = 32px
	  
	  代码
	  <div class="div-rem">rem</div>
	  复制代码
	  /* rem的用法 */
	  html{
	      font-size:16px;  // 1rem = 16px
	  }
	  
	  .div-rem{
	      width: 10rem;    // 10rem = 10 x 16 = 160px
	      height: 10rem;   // 10rem = 10 x 16 = 160px
	      font-size: 1rem; // 1rem = 16px
	      background-color: #a58778;
	  }

	- vm、vh

	  vh 和 vw 就是根据窗口的宽高，分成100等份，100vh就表示满高，50vh就表示一半高。
	  
	  那么vh 和 vw与百分比的区别是什么？🤔
	  百分比是基于父元素的设置而言的，如果父元素为100px，那么子元素100%也就是100px。
	  而 vh 和 vw 始终是针对窗口的宽高。
	  
	  代码
	  
	  <!--vh vw-->
	  <div class="div-vh-vw">
	  
	      <!--百分比%-->
	      <div class="div-vh-vw-child"></div>
	      
	  </div>
	  复制代码
	   /* vh vw 的用法：视窗最为参照值 */
	  .div-vh-vw{
	      width: 10vw;  // 视窗宽度的 1/10
	      height: 10vh;  // 视窗高度的 1/10
	      background-color: pink;
	  }
	  
	  /* %百分比的用法：父元素的宽高作为参照值 */
	  .div-vh-vw-child{
	      width: 50%;
	      height: 50%;
	      background-color: aliceblue;
	  }

### input框类别

常用的并且能为大多数浏览器所识别的类型大概有：text、password、number、button、reset、submit、hidden、radio、checkbox、file、image、color、range、date、month、week、time、datetime-local。

另外还有一些类型：tel、email、url、datetime、search。这些类型部分浏览器不支持识别或校验。

- text
- number
- checkbox
- password
- file
- date
- time

### 实现一个块从左到右的移动

### Link与@import的区别

- link是异步操作 遇到link不会开辟新的HTTP线程去获取资源 GUI继续渲染页面；

  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Document</title>
    <!-- 实例1. link标签引入yellow.css，内联样式引入green.css -->
    <link rel="stylesheet" href="yellow.css">
    <style type="text/css">
      @import url("green.css");
    </style>
  </head>
  <body>
    <div style="width: 50px; height: 50px;"></div>
    <!-- 盒子为，绿色背景，红色边框，即green.css生效 -->
  </body>
  </html>

- @import 是同步的 GUI渲染页面的时候遇到@import会等它获取新的样式回来后继续渲染

  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Document</title>
    <!-- 实例2. 内联样式引入green.css，link标签引入yellow.css -->
    <style type="text/css">
      @import url("green.css");
    </style>
    <link rel="stylesheet" href="yellow.css">
  </head>
  <body>
    <div style="width: 50px; height: 50px;"></div>
    <!-- 盒子为黄色背景，黑色边框，即yellow.css生效 -->
  </body>
  </html>

## HTML基础

### 你是如何理解 HTML 语义化的？

- 概念

  语义化是指 代码语义化 及 内容结构化（也就是内容语义化）选择合适的标签（语义化标签）放到对应的位置，总的来说就是 对的人做对的事。

- 语义化的优点

  对机器友好 有利于SEO优化
  有利于爬虫爬取有效信息
  语义化还支持读屏软件根据文章自动生成目录、
  对开发者友好 增强了代码可读性 便于团队的开发和维护

- 常见的语义化标签

  <header></header>      定义文档头部
  <nav></nav>         定义导航栏
  <section></section>     区块（有语义的div）
  <main></main>        主要区域
  <article></article>     主要内容
  <aside></aside>       侧边栏
  <footer></footer>      底部

### 常考标签

- head标签

  head标签与html标签，body标签一样是一个文档必须的元素。
  head标签用于定于文档头部信息，它是所有头部元素的容器。head中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等等。
  文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。
  下面这些标签可用在 head 部分：base, link, meta, script, style, 以及 title。
  注意:应该把 head 标签放在文档的开始处，紧跟在 html 后面，并处于 body 标签或 frameset 标签之前。

- title标签

  title 定义文档的标题，它是 head 部分中唯一必需的元素。浏览器会以特殊的方式来使用标题，设置的内容不会显示在页面中，通常把它放置在浏览器窗口的标题栏或状态栏上，如设置为空标题展示当前页面的地址信息。
  当把文档加入用户的链接列表或者收藏夹或书签列表时，标题将成为该文档链接的默认名称。

- base标签

  base标签定义了文档的基础url地址，在文档中所有的相对地址形式的url都是相对于这里定义的url而言的。为页面上的链接规定默认地址或目标。
  
  <base href="http://www.w3school.com.cn/i/" target="_blank" />
  复制代码
  base标签包含的属性。
  
  1. href
  href是必选属性，指定了文档的基础url地址。例如，如果希望将文档的基础URL定义为https：//www.abc.com，则可以使用如下语句：<base href="http://www.abc.com">如果文档的超链接指向welcom.html,则它实际上指向的是如下url地址：https://www.abc.com/welocme.html。
  
  2. target
  定义了当文档中的链接点击后的打开方式_blank，_self，_parrent，_top。

- link 标签

  link用于引入外部样式表，在html的头部可以包含任意数量的link，link标签有以下常用属性。
  <link type="text/css" rel="stylesheet" href="github-markdown.css">
  1. type
  定义包含的文档类型，例如text/css
  2. rel
  定义html文档和所要包含资源之间的链接关系，可能的值有很多，最为常用的是stylesheet，用于包含一个固定首选样式的表单。
  3. href
  表示指向被包含资源的url地址。

- style标签

  编写内部样式表的标签。
  <style>
      body {
          background: #f3f5f9;
      }
  </style>

- script标签

  加载javascript脚本的标签。加载的脚本会被默认执行。默认情况下当浏览器解析到script标签的时候会停止html的解析而开始加载script代码并且执行。
  <script src="script.js"></script>
  1. type
  指示脚本的MIME类型。
  <script type="text/javascript">
  共同进行的，但是script的执行要在所有元素解析完成之后，DOMContentLoaded事件触发之前完成。
  
  <script defer src="script.js"></script>
  复制代码
  
  2. async
  规定异步执行脚本，仅适用于通过src引入的外部脚本。设置的async属性的script加载不会影响后面html的解析，加载是与文档解析同时发生的。加载完成后立即执行。执行过程会停止html文档解析。
  
  <script async src="script.js"></script>
  复制代码
  3. charset
  规定在外部脚本文件中使用的字符编码。
  
  <script type="text/javascript" src="script.js" charset="UTF-8"></script>
  复制代码
  
  4. defer
  规定是否对脚本执行进行延迟，直到页面加载为止。设置了defer属性的script不会阻止后面html的解析，加载与解析是共同进行的，但是script的执行要在所有元素解析完成之后，DOMContentLoaded事件触发之前完成。
  
  <script defer src="script.js"></script>
  
  5. language
  规定脚本语言，与``type```功能类似，不建议使用该字段。
  
  6. src
  外部脚本的地址。
  <script src="script.js"></script>

### meta标签的用处

meta 元素往往不会引起用户的注意，但是meta对整个网页有影响，会对网页能否被搜索引擎检索，和在搜索中的排名起着关键性的作用。
meta有个必须的属性content用于表示需要设置的项的值。
meta存在两个非必须的属性http-equiv和name, 用于表示要设置的项。
比如<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">,设置的项是Content-Security-Policy设置的值是upgrade-insecure-requests。

- http-equiv 属性

	- content-type

	  比如：<meta http-equiv="content-type" content="text/html charset=utf8">可以用来声明文档类型、设字符集，目前content-type只能在html文档中使用。
	  这样设置浏览器的头信息就会包含:
	  
	  content-type: text/html charset=utf8

	- expires

	  用于设置浏览器的过期时间, 其实就是响应头中的expires属性。
	  <meta http-equiv="expires" content="31 Dec 2021">
	  复制代码
	  expires:31 Dec 2008

	- refresh

	  该种设定表示5秒自动刷新并且跳转到指定的网页。如果不设置url的值那么浏览器则刷新本网页。
	  <meta http-equiv="refresh" content="5 url=http://www.zhiqianduan.com">

	- window-target

	  强制页面在当前窗口以独立页面显示, 可以防止别人在框架中调用自己的页面。
	  <meta http-equiv="window-target" content="_top'>

	- pragma

	  禁止浏览器从本地计算机的缓存中访问页面的内容
	  <meta http-equiv="pragma" content="no-cache">

	- Cache-Control

	  百度禁止转码
	  百度会自动对网页进行转码，这个标签是禁止百度的自动转码
	  <meta http-equiv="Cache-Control" content="no-siteapp" />

- name 属性

	- author

	  author用来标注网页的作者
	  <meta name="author" content="aaa@mail.abc.com">

	- description

	  description用来告诉搜素引擎当前网页的主要内容，是关于网站的一段描述信息。
	  <meta name="description" content="这是我的HTML">

	- keywords

	  keywords设置网页的关键字，来告诉浏览器关键字是什么。是一个经常被用到的名称。它为文档定义了一组关键字。某些搜索引擎在遇到这些关键字时，会用这些关键字对文档进行分类。
	  
	  <meta name="keywords" content="Hello world">

	- generator

	  表示当前html是用什么工具编写生成的，并没有实际作用，一般是编辑器自动创建的。
	  <meta name="generator" content="vscode">

	- revised

	  指定页面的最新版本
	  <meta name="revised" content="V2，2015/10/1">

	- robots

	  告诉搜索引擎机器人抓取哪些页面，all / none / index / noindex / follow / nofollow。
	  
	  <meta name="robots" content="all">
	  复制代码
	  all：文件将被检索，且页面上的链接可以被查询； none：文件将不被检索，且页面上的链接不可以被查询； index：文件将被检索； follow：页面上的链接可以被查询； noindex：文件将不被检索，但页面上的链接可以被查询； nofollow：文件将不被检索，页面上的链接可以被查询。

	- viewport

	  viewport主要是影响移动端页面布局的，例如：
	  
	  <meta name="viewport" content="width=device-width, initial-scale=1.0">
	  复制代码
	  content 参数：
	  
	  width viewport 宽度(数值/device-width)
	  height viewport 高度(数值/device-height)
	  initial-scale 初始缩放比例
	  maximum-scale 最大缩放比例
	  minimum-scale 最小缩放比例
	  user-scalable 是否允许用户缩放(yes/no)

- 移动端常用的meta

  最后——移动端常用的meta
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  <meta name="format-detection"content="telephone=no, email=no" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" /><!-- 删除苹果默认的工具栏和菜单栏 -->
  <meta name="apple-mobile-web-app-status-bar-style" content="black" /><!-- 设置苹果工具栏颜色 -->
  <meta name="format-detection" content="telphone=no, email=no" /><!-- 忽略页面中的数字识别为电话，忽略email识别 -->
  <!-- 启用360浏览器的极速模式(webkit) -->
  <meta name="renderer" content="webkit">
  <!-- 避免IE使用兼容模式 -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 -->
  <meta name="HandheldFriendly" content="true">
  <!-- 微软的老式浏览器 -->
  <meta name="MobileOptimized" content="320">
  <!-- uc强制竖屏 -->
  <meta name="screen-orientation" content="portrait">
  <!-- QQ强制竖屏 -->
  <meta name="x5-orientation" content="portrait">
  <!-- UC强制全屏 -->
  <meta name="full-screen" content="yes">
  <!-- QQ强制全屏 -->
  <meta name="x5-fullscreen" content="true">
  <!-- UC应用模式 -->
  <meta name="browsermode" content="application">
  <!-- QQ应用模式 -->
  <meta name="x5-page-mode" content="app">
  <!-- windows phone 点击无高光 -->
  <meta name="msapplication-tap-highlight" content="no">
  <!-- 适应移动端end -->

### 你用过哪些 HTML 5 标签？

- video    表示一段视频并提供播放的用户界面    
- audio    表示音频    
- canvas    表示位图区域    
- source    为video和audio提供数据源    
- track    为video和audio指定字母    
- svg    定义矢量图    
- code    代码段    
- figure    和文档有关的图例    
- figcaption    图例的说明    
- main    
- time    日期和时间值    
- mark    高亮的引用文字    
- datalist    提供给其他控件的预定义选项    
- keygen    秘钥对生成器控件    
- output    计算值    
- progress    进度条    
- menu    菜单    
- embed    嵌入的外部资源    
- menuitem    用户可点击的菜单项    
- menu    菜单    
- template    
- section    
- nav    
- aside    
- article    
- footer    
- header

### 介绍一下DOCTYPE

在开始学习前端之前，你总会需要创建一个 HTML。在 HTML 标签之前，还有一个你可能不会注意到的<!DOCTYPE>标记。虽然它不显眼，但我们需要知道它为什么存在。
HTML 文件中，<!DOCTYPE>是必须的，需要放到整个文档的顶部，格式为<!DOCTYPE html>。它存在的意义在于阻止浏览器在渲染文档时进入混杂模式(Quirks Mode)。也就是说<!DOCTYPE html>这一文档类型可以确保浏览器尽可能地使用遵循规范的模式来渲染，而不是使用某些不符合规范的渲染模式。

很久很久以前，web 页面主要运行在两类浏览器：网景的 Navigator 和微软的 IE。后来 W3C 制定了 web 规范之后，为了保证现有页面可用，各大浏览器不能立马使用新规范。
于是，浏览器厂商们引入了两种模式来区别对待符合新标准的站点和旧的遗留站点：混杂模式（Quirks Mode）和标准模式（Standards Mode）。在过渡阶段还存在一种接近标准模式（Almost Standards Mode）。

混杂模式，也成为怪异模式，会兼容 Navigator 4 和 IE 5 的非标准行为。
近标准模式会兼容少数的混杂行为，可以理解为过渡模式。
标准模式只兼容符合标准描述的行为。
请确保把 DOCTYPE 放在 HTML 文件的顶部。如果有任何其他字符位于 DOCTYPE 之前，比如注释或 XML 声明，会导致 Internet Explorer 9 或更早期的浏览器触发混杂模式。
如果你想知道有哪些混杂行为，可以参考混杂列表。近标准模式与混杂模式的区别参考这个链接。

二、如何查看页面的渲染模式
在 Firefox 中，请从右键菜单选择查看页面信息，然后查看渲染模式。
在 Internet Explorer 中，请按下F12，然后查看文档模式。
document.doctype可以返回声明的文档类型。
举个 Firefox 的例子：


三、有哪些文档类型
文档类型有很多，多到歪马不想一一列举，具体参见下图：

来源：https://hsivonen.fi/doctype/
图中列举了不同浏览器对于不同类型的文档类型选择什么模式来渲染。其中包含了 HTML 发展过程中不同版本所使用的文档类型。文档类型很多，好在我们不需要记住。HTML5 之后，我们只需要指定<!DOCTYPE html>即可让浏览器尽可能地按照标准来渲染。
此外，如果你的网页使用 XHTML[1] 并在 Content-Type HTTP 标头使用application/xhtml+xml MIME 类型，你不需要使用 DOCTYPE 启动标准模式，因为这种文件会永远使用标准模式。不过由于 IE9 才支持 XHTML，所以 IE9 之前的浏览器会因为不识别的格式，出现下载对话框。


四、🌟 标准类型下的“怪异”行为
我们应该都遇到过这个问题，div 里面如果装着一个 img，会被无故撑高几个像素。效果如下图所示（示例链接）：


这个很奇怪。如果我说这个奇怪的现象只有标准模式才会有，近标准模式和怪异模式下是没问题的，你应该会觉得更奇怪。
近标准模式效果可以参考该示例。
怪异模式效果可以参考该示例。
具体的缘由是这样的：
近标准模式和标准模式之间的唯一区别在于是否对<img>元素给定行高(line-height)和基线(baseline)。
近标准模式中，如果<img>标签所在行没有其他的行内元素，将不指定基线对齐(baseline)，<img>标签因此会紧贴着父元素底部。
在标准模式中，<img>标签会指定基线对齐baseline。即使行框内并没有任何内容，行框总是会包含类似字母"g"，"f"尾巴下伸出来的那一部分空间(针对下行字母)。因此这种情况下你看到的<img>跟父元素的底部存在几个像素的间隙，这实际上是为”字母尾巴“预留的。
这一现象虽然怪异，但也是标准对于文本对齐的一种规范处理。

由于标准模式指定了默认的baseline对齐方式导致了这一问题，所以想要解决也很简单，给<img>标签指定vertical-align: middle;即可。

## JS

### 执行上下文

### 作用域/作用域链

作用域就是一个独立的地盘，能够访问和修改里面的值，并且变量不会外泄，不同作用域中同名变量也不会冲突
Es6之前只有全局作用域和函数作用域，Es6新增了块级作用域(let 和 const）

如图，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的全局作用域为止，如果还是没有找到就报错
而这一层一层嵌套起来的作用域，就形成了作用域链
做道题，理解作用域

function foo(){
  console.log(a);
}
function bar(){
  var a = 3;
  foo();
}
var a = 2;
bar()

### 闭包

闭包是指一个函数有权访问外部作用域中的变量，这个函数就是闭包，所以 所有的 JS 函数都是闭包，因为他们都是对象，都关联到了作用域链
优点：

内部函数有权访问外部函数的局部变量
缺点：

内部函数引用的变量会在内存中，不会立刻销毁;
因为内部函数有权访问外部函数，所以外部函数执行完了也不会被垃圾回收，而占用内存;
如果闭包用得太多会导致性能降低

### 原型/原型链

- 原型

  我们都知道new了一个新的实例之后，我们什么都没做就可以直接访问toString(),valueOf()等一些方法，那这些方法是从哪来的呢？
  答案就是原型，来我们先看一张图
  
  对照图片，我们看几行代码
  
  function Parent(){} // 这就是构造函数
  let child = new Parent() // child就是实例
  
  Parent.prototype.getName = function(){ console.log('沐华') } // getName是构造函数的原型对象上的方法
  child.getName() // '沐华' 这是继承来的方法
  复制代码
  prototype ：它是构造函数的原型对象。每个函数都会有这个属性，强调一下，是函数，其他对象是没有这个属性的
  __proto__ ：它指向构造函数的原型对象。每个对象都有这个属性，强调一下，是对象，同样，因为函数也是对象，所以函数也有这个属性。不过访问对象原型(child.__proto__)的话，建议用Es6的Reflect.getPrototypeOf(child)或者Object.getPrototypeOf(child)方法
  constructor ：这是原型对象上的指向构造函数的属性，也就是说代码中的 Parent.prototype.constructor === Parent 是为 true 的

- 原型链

  每个对象都有一个_proto_属性指向原型对象，原型对象也是对象，所以也有_proto_指向原型对象的原型对象，一层一层往上，形成起来的链式关系，就是原型链
  原型链也决定了js中的继承方式，当我们访问一个属性时：
  
  先访问对象的实例属性，找到就返回，没有就通过__proto__去原型对象中找
  在原型对象上找到，就返回，没有继续通过原型的__proto__向上层查找
  一直到Object.prototype，找到就返回，没有就返回undefined，不找了
  原型链的最上层对象就是Object，那Object构造函数的原型是谁？
  答案是自身，它的constructor指向Object，而它的_proto_则指向null

- 原型污染

  原型污染是指攻击者通过某种手段修改js的原型
  
  Object.prototype.toString = function () {alert('原生方法被改写，已完成原型污染')};

### 继承

上面说了对象之间有一个原型对象指针__proto__关联，形成链式结构，所以一个对象就可以通过这个关联访问另一个对象的属性和函数，这就是继承
ES6 继承

class Parent(){
    constructor(props){
        this.name = '沐华'
    }
}
// 继承
class Child extends Parent{
    // props是继承过来的属性， myAttr是自己的属性
    constructor(props, myAttr){
        // 调用父类的构造函数，相当于获得父类的this指向
        super(props)
    }
}
console.log(new Child().name) // 沐华
复制代码
虽然现在都用 ES6 的 class，但是 ES5 的继承面试还是会问
ES5 继承
ES5 的继承方式有很多种，什么原型链继承、组合继承、寄生式继承...等等，了解一种面试就够用了

function Parent(){}
Parent.prototype.getName = function(){ return '沐华' }

function Child(){}
// 方式一
Child.prototype = Object.create(Parent.prototype)
Child.prototype.constructor = Child // 重新指定 constructor
// 方式二
Child.prototype = Object.create(Parent.prototype，{
    constructor:{
        value: Child,
        writable: true, // 属性能不能修改
        enumerable: true, // 属性能不能枚举(可遍历性)，比如在 for in/Object.keys/JSON.stringify
        configurable: true, // 属性能不能修改属性描述对象和能否删除
    }
})

console.log(new Child().getName()) // 沐华

### this

它指向什么完全取决于函数在哪里调用，在 Es5 中 this 永远指向调用它的那个对象，而在 Es6 的箭头函数中没有this 绑定，this 指向箭头函数定义时所在的作用域中的 this
判断this

全局作用域、自执行函数、定时器传进的非箭头函数的 this 都指向 window
严格模式(use strict)下的 this 指向 undefined
构造函数中的this指向当前的实例
事件绑定函数中的this指向当前被绑定的元素
箭头函数中this指向定义箭头函数的上级作用域中的this
改变this指向

使用 call, apply, bind，call 和 apply 改变 this 指向时，函数会立即执行，bind 不会
保存成变量(let self = this)
使用箭头函数
使用 new 实例化一个对象
严格模式下直接调用函数 this 指向 undefined
箭头函数硬绑定的 this 无法被修改，比如 fn.call(window)，再把 fn 赋值给对象的属性后，调用对象的方法 this 依然是 window

### 类型判断

- typeof

	- 基础类型

	  typeof 1 === "number" // true
	  typeof "a" === "string" // true
	  typeof true === "boolean" // true
	  typeof undefined === "undefined" // true
	  typeof Symbol() === "symbol" // true

	- 引用类型

	  引用类型
	  typeof null === "object" // true
	  typeof {} === "object" // true
	  typeof [] === "object" // true
	  typeof function () {} === "function" // true

- instanceof

  判断是否出现在该类型原型链中的任何位置，判断引用类型可还行？一般判断一个变量是否属于某个对象的实例
  
  console.log(null instanceof Object) // false
  console.log({} instanceof Object) // true
  console.log([] instanceof Object) // true
  console.log(function(){} instanceof Object) // true

- toString

  toString
  
  let toString = Object.prototype.toString
  
  console.log(toString.call(1)) // [object Number]
  console.log(toString.call('1')) // [object String]
  console.log(toString.call(true)) // [object Boolean]
  console.log(toString.call(undefined)) // [object Undefined]
  console.log(toString.call(null)) // [object Null]
  console.log(toString.call({})) // [object Object]
  console.log(toString.call([])) // [object Array]
  console.log(toString.call(function(){})) // [object Function]
  console.log(toString.call(new Date)) // [object Date]

- 其他判断

  其他判断
  
  // constructor  判断是否是该类型直接继承者
  let A = function(){}
  let B = new A()
  A.constructor === Object // false
  A.constructor === Function // true
  B.constructor === Function // false
  B.constructor === A // true
  
  // 判断数组
  console.log(Array.isArray([])) // true
  // 判断数字
  function isNumber(num) {
    let reg = /^[0-9]+.?[0-9]*$/
    if (reg.test(num)) {
      return true
    }
    return false
  }
  
  //封装获取数据类型
  function getType(obj){
      let type = typeof obj
      if(type !== 'object'){
          return type
      }
      return Object.prototype.toString.call(obj)
  }
  
  // 含隐式类型转换 继续往下看
  
  // 判断数字
  function isNumber(num) {  
      return num === +num
  }
  // 判断字符串
  function isString(str) {  
      return str === str+""
  }
  // 判断布尔值
  function isBoolean(bool) {  
      return bool === !!bool
  }

### 类型转换

- 显示转换

	- Number()

	  1. Number()
	  
	  console.log(Number(1)) // 1
	  console.log(Number("1")) // 1
	  console.log(Number("1a")) // NaN
	  console.log(Number(true)) // 1
	  console.log(Number(undefined)) // NaN
	  console.log(Number(null)) // 0
	  console.log(Number({a:1})) // NaN 原因往下看
	  复制代码
	  原始类型转换
	  
	  数字：转换后还是原来的值
	  字符串：如果能被解析成数字，就得到数字，否则就是 NaN，空字符串为0
	  布尔值：true 转为1，false 转为0
	  undefined: 转为 NaN
	  null：转为0
	  引用类型转换
	  
	  let a = {a:1}
	  console.log(Number(a)) // NaN
	  // 原理
	  a.valueOf() // {a:1}
	  a.toString() // "[object Object]"
	  Number("[object Object]") // NaN
	  复制代码
	  先调用对象自身的 valueOf 方法，如果该方法返回原始类型的值(数值、字符串和布尔值)，则直接对该值使用 Number 方法，不再继续
	  如果 valueOf 方法返回复合类型的值，再调用对象自身的 toString 方法，如果 toString 方法返回原始类型的值，则对该值使用 Number 方法，不再继续
	  如果 toString 方法返回的还是复合类型的值，则报错

	- String()

	  2. String()
	  
	  console.log(String(1)) // "1"
	  console.log(String("1")) // "1"
	  console.log(String(true)) // "true"
	  console.log(String(undefined)) // "undefined"
	  console.log(String(null)) // "null"
	  console.log(String({b:1})) // "[object Object]" 原因往下看
	  复制代码
	  原始类型转换
	  
	  数字：转换成相应字符串
	  字符串：转换后还是原来的值
	  布尔值：true 转为"true"，false 转为"false"
	  undefined: 转为"undefined"
	  null：转为"null"
	  引用类型转换
	  
	  let b = {b:1}
	  console.log(String(b)) // "[object Object]"
	  // 原理
	  b.toString() // "[object Object]"
	  // b.valueOf() 由于返回的不是复合类型所以没有调valueOf()
	  String("[object Object]") // "[object Object]"
	  复制代码
	  先调用 toString 方法，如果 toString 方法返回的是原始类型的值，则对该值使用 String 方法，不再继续
	  如果 toString 方法返回的是复合类型的值，再调用 valueOf 方法，如果 valueOf 方法返回的是原始类型的值，则对该值使用 String 方法，不再继续
	  如果 valueOf 方法返回的是复合类型的值，则报错

	- Boolean()

	  3. Boolean()
	  
	  console.log(Boolean(0)) // flase
	  console.log(Boolean(-0)) // flase
	  console.log(Boolean("")) // flase
	  console.log(Boolean(null)) // flase
	  console.log(Boolean(undefined)) // flase
	  console.log(Boolean(NaN)) // flase
	  复制代码
	  原始类型转换
	  
	  0
	  -0
	  ""
	  null
	  undefined
	  NaN
	  以上统一转为false，其他一律为true

- 隐式转换

  隐式转换
  
  // 四则运算  如把String隐式转换成Number
  console.log(+'1' === 1) // true
  
  // 判断语句  如把String隐式转为Boolean
  if ('1') console.log(true) // true
  
  // Native调用  如把Object隐式转为String
  alert({a:1}) // "[object Object]"
  console.log(([][[]]+[])[+!![]]+([]+{})[!+[]+!![]]) // "nb"
  
  // JSON方法 如把String隐式转为Object
  console.log(JSON.parse("{a:1}")) // {a:1}
  复制代码
  几道隐式转换题
  
  console.log( true+true  ) // 2                   解：true相加是用四则运算隐式转换Number 就是1+1
  console.log(  1+{a:1}   ) // "1[object Object]"  解：上面说了Native调用{a:1}为"[object Object]"  数字1+字符串直接拼接
  console.log(   []+[]    ) // ""                  解：String([]) =》 [].toString() = "" =》 ""+"" =》 ""
  console.log(   []+{}    ) // "[object Object]"   解："" + String({}) =》 "" + {}.toString() = "" + "[object Object]" =》 "[object Object]"
  console.log(   {}+{}    ) // "[object Object][object Object]" 和上面同理
  复制代码
  运算符优先级，图来自MDN

### 深浅拷贝

- 浅拷贝

  第一层是引用类型就拷贝指针，不是就拷贝值。拷贝栈不拷贝堆
  
  // 1. 展开运算符 ...
  let obj1 = { a:1, b:{ c:3 } }
  let obj2 = { ...obj1 }
  obj1.a = 'a'
  obj1.b.c = 'c'
  console.log(obj1) // { a:'a', b:{ c:'c' } }
  console.log(obj2) // { a:1, b:{ c:'c' } }
  
  // 2. Object.assign() 把obj2合并到obj1
  Object.assign(obj1, obj2)
  
  // 3. 手写
  function clone(target){
      let obj = {}
      for(let key in target){
          obj[key] = target[key]
      }
      return obj
  }
  
  // 4. 数组浅拷贝  用Array方法 concat()和slice()
  let arr1 = [ 1,2,{ c:3 } ]
  let arr2 = arr1.concat()
  let arr3 = arr1.slice()

- 深拷贝

  拷贝栈也拷贝堆，重新开僻一块内存
  1. JSON.parse(JSON.stringify())
  
  let obj1 = { a:1, b:{ c:3 } }
  let obj2 = JSON.parse(JSON.stringify(obj1))
  obj1.a = 'a'
  obj1.b.c = 'c'
  console.log(obj1) // { a:'a', b:{ c:'c' } }
  console.log(obj2) // { a:1, b:{ c:3 } }
  复制代码
  该方法可以应对大部分应用场景，但是也有很大缺陷，比如拷贝其他引用类型，拷贝函数，循环引用等情况
  2. 手写递归
  原理就是递归遍历对象/数组，直到里面全是基本类型为止再复制
  需要注意的是 属性引用了自身的情况，就会造成循环引用，导致栈溢出
  解决循环引用 可以额外开僻一个存储空间，存储当前对象和拷贝对象的关系，当需要拷贝对象时，先去存储空间找，有木有这个拷贝对象，如果有就直接返回，如果没有就就继续拷贝，这就解决了
  这个存储空间可以存储成key-value的形式，且key可以是引用类型，选用Map这种数据结构。检查map中有木有克隆过的对象，有就直接直接返回，没有就将当前对象作为key，克隆对象作为value存储，继续克隆
  
  function clone(target, map = new Map()){
      if (typeof target === 'object') { // 引用类型才继续深拷贝
          let obj = Array.isArray(target) ? [] : {} // 考虑数组
          //防止循环引用
          if (map.get(target)) {
              return map.get(target) // 有拷贝记录就直接返回
          }
          map.set(target,obj) // 没有就存储拷贝记录
          for (let key in target) {
              obj[key] = clone(target[key]) // 递归
          }
          return obj
      } else {
          return target
      }
  }
  复制代码
  优化版
  
  用WeakMap替代Map，上面说了WeakMap是弱引用，Map是强引用
  选择性能更好的循环方式
  for in 每次迭代操作会同时搜索实例和原型属性，会产生更多的开销，所以用 while
  
  // 用while来实现一个通用的forEach遍历
  function forEach(array, iteratee) {
      let index = -1;
      const length = array.length;
      while (++index < length) {
          iteratee(array[index], index);
      }
      return array;
  }
  // WeakMap 对象是键/值对集合，键必须是对象，而且是弱引用的，值可以是任意的
  function clone(target, map = new WeakMap()){
      // 引用类型才继续深拷贝 
      if (target instanceof Object) {
          const isArray = Array.isArray(target)
          // 克隆对象和数组类型
          let cloneTarget = isArray ? [] : {} 
          
          // 防止循环引用
          if (map.get(target)) {
              // 有拷贝记录就直接返回
              return map.get(target) 
          }
          // 没有就存储拷贝记录
          map.set(target,cloneTarget) 
          
          // 是对象就拿出同级的键集合  返回是数组格式
          const keys = isArray ? undefined : Object.keys(target)
          // value是对象的key或者数组的值 key是下标 
          forEach(keys || target, (value, key) => { 
              if (keys) {
                  // 是对象就把下标换成value
                  key = value 
              }
              // 递归
              cloneTarget[key] = clone(target[key], map) 
          })
          return cloneTarget
      } else {
          return target
      }
  }

### ES6新特性

- let / const
- 箭头函数
- 解构赋值
- 默认参数
- 扩展运算符
- 类
- 字符串
- 数组新方法：copyWithin、fill、find、entries
- Promise

### 事件循环

这几个主要都是考笔试题，所以只要会手写 Promise 的几个方法，知道事件循环，就肯定没问题了
Promise 构造函数是同步执行的，then 方法是异步执行的(微任务)
async/await 本质上就是 Promise，只不过她可以在不阻塞主线程的情况下，使用同步代码实现异步访问。
缺点是 await 会阻塞代码，要是她之后的异步代码不依赖她的结果，也还是要等她完成，失去了并发性，这时候就建议用 Promise.all
看例子，顺便复习事件循环

async function fun() {
    console.log(1)
    let a = await 2
    console.log(a)
    console.log(3)
}
console.log(4)
fun()
console.log(5)
复制代码
输出结果：4 1 5 2 3
结合 async / await 的特点，我们来把这个题用 ES6 翻译一下

function fun(){
    return new Promise(() => {
        console.log(1)
        Promise.resolve(2).then( a => {
            console.log(a)
            console.log(3)
        })
    })
}
console.log(4)
fun()
console.log(5)
复制代码
想研究一下 Promise 的可以看这篇文章 Promise 你真的用明白了么
最后问一个问题： async/await 经过编译后和 generator 有啥联系？

### Ajax

### Promise

这几个主要都是考笔试题，所以只要会手写 Promise 的几个方法，知道事件循环，就肯定没问题了
Promise 构造函数是同步执行的，then 方法是异步执行的(微任务)
async/await 本质上就是 Promise，只不过她可以在不阻塞主线程的情况下，使用同步代码实现异步访问。
缺点是 await 会阻塞代码，要是她之后的异步代码不依赖她的结果，也还是要等她完成，失去了并发性，这时候就建议用 Promise.all
看例子，顺便复习事件循环

async function fun() {
    console.log(1)
    let a = await 2
    console.log(a)
    console.log(3)
}
console.log(4)
fun()
console.log(5)
复制代码
输出结果：4 1 5 2 3
结合 async / await 的特点，我们来把这个题用 ES6 翻译一下

function fun(){
    return new Promise(() => {
        console.log(1)
        Promise.resolve(2).then( a => {
            console.log(a)
            console.log(3)
        })
    })
}
console.log(4)
fun()
console.log(5)
复制代码
想研究一下 Promise 的可以看这篇文章 Promise 你真的用明白了么
最后问一个问题： async/await 经过编译后和 generator 有啥联系？

### Generator与async/await

### 垃圾回收

- 垃圾产生&为何回收

  我们知道写代码时创建一个基本类型、对象、函数……都是需要占用内存的，但是我们并不关注这些，因为这是引擎为我们分配的，我们不需要显式手动的去分配内存
  但是，你有没有想过，当我们不再需要某个东西时会发生什么？JavaScript 引擎又是如何发现并清理它的呢？
  我们举个简单的例子
  
  let test = {
    name: "isboyjc"
  };
  test = [1,2,3,4,5]
  复制代码
  如上所示，我们假设它是一个完整的程序代码
  我们知道 JavaScript 的引用数据类型是保存在堆内存中的，然后在栈内存中保存一个对堆内存中实际对象的引用，所以，JavaScript 中对引用数据类型的操作都是操作对象的引用而不是实际的对象。可以简单理解为，栈内存中保存了一个地址，这个地址和堆内存中的实际值是相关的
  那上面代码首先我们声明了一个变量 test，它引用了对象 {name: 'isboyjc'}，接着我们把这个变量重新赋值了一个数组对象，也就变成了该变量引用了一个数组，那么之前的对象引用关系就没有了，如下图
  
  没有了引用关系，也就是无用的对象，这个时候假如任由它搁置，一个两个还好，多了的话内存也会受不了，所以就需要被清理（回收）
  用官方一点的话说，程序的运行需要内存，只要程序提出要求，操作系统或者运行时就必须提供内存，那么对于持续运行的服务进程，必须要及时释放内存，否则，内存占用越来越高，轻则影响系统性能，重则就会导致进程崩溃

- 垃圾回收策略

  在 JavaScript 内存管理中有一个概念叫做 可达性，就是那些以某种方式可访问或者说可用的值，它们被保证存储在内存中，反之不可访问则需回收
  至于如何回收，其实就是怎样发现这些不可达的对象（垃圾）它并给予清理的问题， JavaScript 垃圾回收机制的原理说白了也就是定期找出那些不再用到的内存（变量），然后释放其内存
  你可能还会好奇为什么不是实时的找出无用内存并释放呢？其实很简单，实时开销太大了
  我们都可以 Get 到这之中的重点，那就是怎样找出所谓的垃圾？
  这个流程就涉及到了一些算法策略，有很多种方式，我们简单介绍两个最常见的
  
  标记清除算法
  引用计数算法

	- 标记清除算法

	  策略
	  标记清除（Mark-Sweep），目前在 JavaScript引擎 里这种算法是最常用的，到目前为止的大多数浏览器的 JavaScript引擎 都在采用标记清除算法，只是各大浏览器厂商还对此算法进行了优化加工，且不同浏览器的 JavaScript引擎 在运行垃圾回收的频率上有所差异
	  就像它的名字一样，此算法分为 标记 和 清除 两个阶段，标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁
	  你可能会疑惑怎么给变量加标记？其实有很多种办法，比如当变量进入执行环境时，反转某一位（通过一个二进制字符来表示标记），又或者可以维护进入环境变量和离开环境变量这样两个列表，可以自由的把变量从一个列表转移到另一个列表，当前还有很多其他办法。其实，怎样标记对我们来说并不重要，重要的是其策略
	  引擎在执行 GC（使用标记清除算法）时，需要从出发点去遍历内存中所有的对象去打标记，而这个出发点有很多，我们称之为一组 根 对象，而所谓的根对象，其实在浏览器环境中包括又不止于 全局Window对象、文档DOM树 等
	  整个标记清除算法大致过程就像下面这样
	  
	  垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0
	  然后从各个根对象开始遍历，把不是垃圾的节点改成1
	  清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间
	  最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收
	  优点
	  标记清除算法的优点只有一个，那就是实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0和1）就可以为其标记，非常简单
	  缺点
	  标记清除算法有一个很大的缺点，就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 内存碎片（如下图），并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题
	  
	  假设我们新建对象分配内存时需要大小为 size，由于空闲内存是间断的、不连续的，则需要对空闲内存列表进行一次单向遍历找出大于等于 size 的块才能为其分配（如下图）
	  
	  那如何找到合适的块呢？我们可以采取下面三种分配策略
	  
	  First-fit，找到大于等于 size 的块立即返回
	  Best-fit，遍历整个空闲列表，返回大于等于 size 的最小分块
	  Worst-fit，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 size 大小，并将该部分返回
	  这三种策略里面 Worst-fit 的空间利用率看起来是最合理，但实际上切分之后会造成更多的小块，形成内存碎片，所以不推荐使用，对于 First-fit 和 Best-fit 来说，考虑到分配的速度和效率 First-fit 是更为明智的选择
	  综上所述，标记清除算法或者说策略就有两个很明显的缺点
	  
	  内存碎片化，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块
	  分配速度慢，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢
	  PS：标记清除算法的缺点补充
	  归根结底，标记清除算法的缺点在于清除之后剩余的对象位置不变而导致的空闲内存不连续，所以只要解决这一点，两个缺点都可以完美解决了
	  而 标记整理（Mark-Compact）算法 就可以有效地解决，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）

	- 引用计数算法

	  策略
	  引用计数（Reference Counting），这其实是早先的一种垃圾回收算法，它把 对象是否不再需要 简化定义为 对象有没有其他对象引用到它，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收，目前很少使用这种算法了，因为它的问题很多，不过我们还是需要了解一下
	  它的策略是跟踪记录每个变量值被使用的次数
	  
	  当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1
	  如果同一个值又被赋给另一个变量，那么引用数加 1
	  如果该变量的值被其他的值覆盖了，则引用次数减 1
	  当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存
	  如下例
	  
	  let a = new Object() 	// 此对象的引用计数为 1（a引用）
	  let b = a 		// 此对象的引用计数是 2（a,b引用）
	  a = null  		// 此对象的引用计数为 1（b引用）
	  b = null 	 	// 此对象的引用计数为 0（无引用）
	  ...			// GC 回收此对象
	  复制代码
	  这种方式是不是很简单？确实很简单，不过在引用计数这种算法出现没多久，就遇到了一个很严重的问题——循环引用，即对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A ，如下面这个例子
	  
	  function test(){
	    let A = new Object()
	    let B = new Object()
	    
	    A.b = B
	    B.a = A
	  }
	  复制代码
	  如上所示，对象 A 和 B 通过各自的属性相互引用着，按照上文的引用计数策略，它们的引用数量都是 2，但是，在函数 test 执行完成之后，对象 A 和 B 是要被清理的，但使用引用计数则不会被清理，因为它们的引用数量不会变成 0，假如此函数在程序中被多次调用，那么就会造成大量的内存不会被释放
	  我们再用标记清除的角度看一下，当函数结束后，两个对象都不在作用域中，A 和 B 都会被当作非活动对象来清除掉，相比之下，引用计数则不会释放，也就会造成大量无用内存占用，这也是后来放弃引用计数，使用标记清除的原因之一
	  在 IE8 以及更早版本的 IE 中，BOM 和 DOM 对象并非是原生 JavaScript 对象，它是由 C++ 实现的 组件对象模型对象（COM，Component Object Model），而 COM 对象使用 引用计数算法来实现垃圾回收，所以即使浏览器使用的是标记清除算法，只要涉及到  COM 对象的循环引用，就还是无法被回收掉，就比如两个互相引用的 DOM 对象等等，而想要解决循环引用，需要将引用地址置为 null 来切断变量与之前引用值的关系，如下
	  
	  // COM对象
	  let ele = document.getElementById("xxx")
	  let obj = new Object()
	  
	  // 造成循环引用
	  obj.ele = ele
	  ele.obj = obj
	  
	  // 切断引用关系
	  obj.ele = null
	  ele.obj = null
	  复制代码
	  不过在 IE9 及以后的 BOM 与 DOM 对象都改成了 JavaScript 对象，也就避免了上面的问题
	  此处参考 JavaScript高级程序设计 第四版 4.3.2 小节
	  优点
	  引用计数算法的优点我们对比标记清除来看就会清晰很多，首先引用计数在引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾
	  而标记清除算法需要每隔一段时间进行一次，那在应用程序（JS脚本）运行过程中线程就必须要暂停去执行一段时间的 GC，另外，标记清除算法需要遍历堆里的活动以及非活动对象来清除，而引用计数则只需要在引用时计数就可以了
	  缺点
	  引用计数的缺点想必大家也都很明朗了，首先它需要一个计数器，而此计数器需要占很大的位置，因为我们也不知道被引用数量的上限，还有就是无法解决循环引用无法回收的问题，这也是最严重的

- V8对GC的优化

### 正则表达式

### 内存泄露

### 事件机制

### 错误定位

### 面向对象

- 封装

  封装就是隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别，将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。

- 继承

  继承是面向对象的基本特征之一，继承机制允许创建分等级层次的类。继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。

- 多态

  多态同一个行为具有多个不同表现形式或形态的能力。是指一个类实例（对象）的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。

### 事件冒泡

### 事件循环

## 前端工程化

### Webpack相关

- 介绍一下webpack，webpack有哪些配置，loader和plugin有什么区别
- tree-shaking原理
- webpack的打包优化
- webpack的打包流程
- 路由懒加载的原理是啥，能不能结合webpack说一说。
- 写一个webpack插件应该怎么写
- Require/import如何解决循环引用 
Webpack是怎么做的

## 前端优化

### 性能

### seo

- TKD设置

  页面TKD要包含品牌词及业务词，提升页面排名
  例如：掘金的 TKD
  Title：掘金 - 代码不止，掘金不停
  Keywords：掘金,稀土,Vue.js,前端面试题,nginx配置,Kotlin,RxJava,React Native,敏捷开发,Python
  Description：掘金是一个帮助开发者成长的社区,是给开发者用的 Hacker News,给设计师用的 Designer News,和给产品经理用的 Medium。掘金的技术文章由稀土上聚集的技术大牛和极客共同编辑为你筛选出最优质的干货,其中包括：Android、iOS、前端、后端等方面的内容。用户每天都可以在这里找到技术世界的头条内容。与此同时,掘金内还有沸点、掘金翻译计划、线下活动、专栏文章等内容。即使你是 GitHub、StackOverflow、开源中国的用户,我们相信你也可以在这里有所收获。

- 页面内容优化

  （1）网页代码语义化调整：多使用语义话标签，便于爬虫检索。
  
  （2）页面内容关键词强化：在页面大小标题和文案中重复关键词，以达到内容强化目的；关键词汇避免使用图片，便于爬虫检索，收录。
  （3）img 添加 alt 属性，用 h1 标签去写内容关键字

-  引导链接

  网站底部推荐部分保留产品介绍、常见问题汇总等降低跳出率的引导，提高页面留存与转化；或者与所推荐页面形成互链形式，以稳定页面流量权重。

- 移动端优化

  设置移动页面，或将pc页面设置为自适应，增加移动端搜索的体验和留存转化。
  移动页面设计需注意以下规则：
  （1）页面字体、字符大小、文本行间距等设计，应适合手机用户阅读，不可明显过大过小，正文文本字号不小于10pt。
  （2）首屏主体内容必须占屏幕的50%以上。
  （3）主体内容应与其他板块有明显区分，且位于屏幕的中心位置，使用户获取信息时不受任何干扰。
  （4）导航的功能与位置明确，避免用户使用过程中被误导。
  （5）除以上提到的内容外，网站还应避免其他影响页面内容辨识的情况，例如页面出现大面积空白、文本无任何排版、段落/图片排版错乱不整齐、主体内容展示不全等。

-  站外优化

  1）在搜素引擎排名较高的公众平台（百家号 ，知道，贴吧、搜狐、知乎等）发布正面网站信息，以建设良好口碑 ；负面信息排名较高的需删除或者屏蔽处理。
  （2）百度，互动，搜狗等百科的创建更新与维护，(互动百科在今日头条有着较高的排名，现在今日头条也在发展搜素引擎)，百科对树立品牌形象较为重要。
  （3）公关舆情传播，宣传新闻源发布。
  （4）站外推广与外链建设。
  根据竞争对手及品牌业务分析，拓展高质量、高权重的外链渠道、科技论坛、自媒体平台、分类信息网等，发布高质量锚文本外链，另进行友情链接交换，以提高关键词排名及自然流量。

## Vue框架

### Vue的生命周期

父子组件挂载时，生命周期的顺序是什么样的

(父组件由beforeCreate正常走到beforeMount之后子组件由beforeCreate正常走到mounted之后走到父组件mounted)

完整的生命周期函数记住3个关键词(create mount (update) destory)

beforeCreate：进行数据和方法的初始化( 生命周期为创建前的时候el和data都还没有初始化，所以也不能访问 data、computed、 watch、 methods的方法和数据)

created：已经完成数据和方法的初始化(生命周期为创建后的时候，data初始化完成了已经，像data、computed、watch、methods上的方法和数据都是可以访问的。但是el还不能访问，这个时候可以做一些初始化的代码，比如进行axios请求等 (但是这个时候页面还没有被渲染出来，如果请求时间过长的时候会出现白屏的状态))

beforeMount：开始渲染dom(当生命周期为挂载前的时候，data和el都已经完成了初始化，但是页面中的内容还是Vue 的占位符，data里面的数据还没有挂载到dom节点上)

mounted：可以渲染dom(当生命周期是挂载后的时候，el已经挂载好了，将上一个阶段写好在内存中的虚拟dom真正挂载到页面上。可以进行dom操作)

beforeUpdate：data中的数据即将被更新(当生命周期为更新前的时候，这个生命周期是数据更新的时候触发，这个时候更新的数据和模板还没有结合，可以在这个生命周期做数据的最后一次修改。)

updated：data中的数据更新完毕(当生命周期为更新后的时候，更新的数据和模板结合完毕)

beforeDestroy：实例即将被销毁(当生命周期为销毁前的时候，此时实例还在还是可以做操作的，在这里可以做一些，移除监听啊，事件解绑什么的。)

destroyed：实例已经被销毁( 当生命周期为销毁后的时候，整个生命周期已经完成了销毁，生命周期数据与视图之间的关系将会断开 这就是差不多在面试的时候你需要说出来的点，特别是Created ，Mounted ，BeforeDestroy 这三个生命周期问得最多，一个是完成初始化，一个是dom加载完成，一个是销毁之前。)

### 响应式系统原理

Vue是采用数据劫持配合发布者-订阅者模式，通过Object.defineProperty来()来劫持各个属性的getter和setter
在数据发生变化的时候，发布消息给依赖收集器，去通知观察者，做出对应的回调函数去更新视图。
 
具体就是：
MVVM作为绑定的入口，整合Observe,Compil和Watcher三者，通过Observe来监听model的变化
通过Compil来解析编译模版指令，最终利用Watcher搭起Observe和Compil之前的通信桥梁
从而达到数据变化 => 更新视图，视图交互变化(input) => 数据model变更的双向绑定效果。

### 通信方式

- 第一种：props和$emit
- 第二种：中央事件总线 EventBus(基本不用)
- 第三种：vuex（状态管理器）
- 第四种：$parent 和 $children

### MVVM与MVC

### 性能优化

### 插槽

### 虚拟DOM

### Dom diff

### vue-router

前端路由

在SPA（单页应用）中根据用户所触发的事件改变了URL 在无需刷新的前提下 显示不同的页面内容，比如等下就要讲的Vue Router

### vuex

Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态
并以相应的规则保证状态以一种可预测的方式发生变化。
tate：Vuex 使用单一状态树——是的，用一个对象就包含了全部的应用层级状态。
mutation：更改 Vuex 的 store 中的状态的唯一方法是提交 mutation
action: action 提交的是 mutation，而不是直接变更状态。action 可以包含任意异步操作。
getter: 相当于Vue中的computed计算属性

### Vue2和Vue3的区别

### Vue与React的区别

### keep-alive

### nextTick

(实现原理：vue用异步队列的方式来控制DOM更新和nextTick回调先后执行microtask因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕)

### methods、computed 和 watch 有什么区别？

methods,watch,computed的区别
1 . computed 属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用；
2 . methods 方法表示一个具体的操作，主要书写业务逻辑；
3 . watch 一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是 computed 和 methods 的结合体；

计算属性的getter与Setter
计算属性默认只有get，在需要的时候也可以设置set方法

fullName: {
get: function () {
  return this.firstName + " " + this.lastName;
},
set: function (val) {
  this.firstName = val.split(' ')[0];
  this.lastName = val.split(' ')[1];
}
}

## 计算机网络

### TCP协议定义

### TCP与UDP的区别

### TCP的三次握手

### TCP的四次挥手

### TCP的超时重传

### TCP的流量控制

### TCP的拥塞控制

### TCP的滑动窗口

### HTTP协议定义

### HTTP报文格式

### HTTP状态码

- 1xx : 表示请求已经接受了，继续处理。
- 2xx : 表示请求已经处理掉了。

  200 OK 客户端请求成功。

- 3xx : 重定向。

  301 Moved Permanently 请求永久重定向。
  302 Moved Temporarily 请求临时重定向。
  304 Not Modified 文件未修改，可以直接使用缓存的文件。

- 4xx : 一般表示客户端有错误，请求无法实现。

  400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。
  401 Unauthorized 请求未经授权，无法访问。
  403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因。
  404 Not Found 请求的资源不存在，比如输入了错误的URL。

- 5xx : 一般为服务器端的错误。

  500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。
  503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。

### HTTP请求方法

### HTTP版本区别

### HTTPS

### HTTP优缺点

### websocket

## 前端安全

### 介绍XSS攻击以及如何防范

XSS攻击 （cross site scipt）是一种代码注入攻击，通过恶意注入脚本在浏览器运行，然后盗取用户信息
造成XSS攻击其实本质上还是因为网站没有过滤恶意代码，与正常代码混在一起之后，浏览器没有办法分辨哪些是可信的，然后导致恶意代码也被执行。然后可能导致以下情况：

页面数据或用户信息被窃取，如DOM、Cookie、LocalStorage
修改DOM，比如伪造登录窗口或在页面生成浮窗广告
监听用户行为，比如在登录或银行等站点用 addEventListener 监听键盘事件，窃取账号密码等信息
流量被劫持向其他网站
XSS攻击有三种类型：存储型、反射型、DOM型

存储型：是在有发贴评论等带有数据保存功能的网站的input、textarea将恶意代码提交到网站数据库中，如<script src="http://恶意网站"></script> ，然后比如在显示评论的页面就会从数据获取，并直接执行这个script标签里的恶意代码
反射型：是攻击者将恶意JS脚本作为用户发送给网站请求中的一部分，然后网站又把恶意脚本返回给用户，这时候就会在页面中被执行。比如打开包含带恶意脚本的链接，当打开后会向服务器请求后，服务器会获取URL中的数据然后拼接在HTML上返回，然后执行。它和存储型不同的是不会储存在服务器里
基于DOM型：就是攻击者通过一些劫持手段，在页面资源传输过程中劫持并修改页面的数据，插入恶意代码

- 攻击类型

	- 存储型

	  是在有发贴评论等带有数据保存功能的网站的input、textarea将恶意代码提交到网站数据库中，如<script src="http://恶意网站"></script> ，然后比如在显示评论的页面就会从数据获取，并直接执行这个script标签里的恶意代码

	- 反射型

	  是攻击者将恶意JS脚本作为用户发送给网站请求中的一部分，然后网站又把恶意脚本返回给用户，这时候就会在页面中被执行。比如打开包含带恶意脚本的链接，当打开后会向服务器请求后，服务器会获取URL中的数据然后拼接在HTML上返回，然后执行。它和存储型不同的是不会储存在服务器里

	- DOM型

	  就是攻击者通过一些劫持手段，在页面资源传输过程中劫持并修改页面的数据，插入恶意代码

- 防攻办法

	- 对输入框的内容进行过滤或使用转义符进行转码

	  那你

	- 使用CSP，就是白名单

	  告诉浏览器哪些外部资源可以加载执行，让即使插入进来恶意代码的也不会执行，或者可以向哪些第三方站点提交数据。开启白名单的方式有两种：
	  
	  使用 meta 标签 <meta http-equiv="Content-Security-Policy">
	  设置http头部的 Content-Security-Policy

	- 保护敏感信息

	  在Cookie信息中添加httpOnly，告诉浏览器在保存Cookie，且不要对客户端脚本开放访问权限，然后就不能通过document.cookie获取cookie了
	  Set-Cookie: widget_session=123456; httpOnly

	- 验证码

	  避免脚本伪装成用户执行一些操作

### 介绍CSRF攻击以及如何防范

就是跨站请求伪造攻击，主要就是利用用户的登录状态发起跨站请求，比如邮箱里的乱七八糟的链接，打开链接的时候邮箱肯定是处于登录状态，然后黑客就可以用这个登录状态，伪造带有正确 Cookie 的 http 请求，直接绕过后台的登录验证，然后冒充用户执行一些操作
发起CSRF攻击有三个必要条件：

目标网站一定要有CSRF漏洞
用户登录过目标网站，并且浏览器保存了登录状态
需要用户主动打开第三方站点
本质是利用cookie在同源请求中携带发送给服务器的特点，来实现冒充用户

- 攻击类型

	- GET类型

	  自动发GET类型：比如img或iframe标签等，当用户打开这个网站时会自动发起带Cookie的资源请求
	  
	  <img src="http://恶意网址" >

	- POST类型

	  自动发POST类型：比如整一个隐藏的表单，在用户进入页面的时候自动提交表单
	  <form id="hack" action="https://恶意网址" method="post">
	      ...
	  </form>
	  <script>document.getElementById('hack').submit()</script>

	- 链接型

	  就是诱导用户主动点击链接，比如a标签
	  <a href="https://恶意网址">点击领取大礼包</a>
	  <a href="https://恶意网址">点击下载美女视频</a>

- 防攻办法

	- 在Cookie信息中添加SameSite属性
	- 验证请求来源
	- Token验证
	- 双重验证Cookie

### 介绍DDOS(分布式拒绝服务攻击)攻击以及如何防范

- 是什么：DDoS攻击通过大量合法的请求占用大量网络资源，以达到瘫痪网络的目的
- 如何防范：

	- 备份网站

	  防范 DDOS 的第一步，就是你要有一个备份网站，或者最低限度有一个临时主页。生产服务器万一下线了，可以立刻切换到备份网站，不至于毫无办法。
	  备份网站不一定是全功能的，如果能做到全静态浏览，就能满足需求。最低限度应该可以显示公告，告诉用户，网站出了问题，正在全力抢修。我的个人网站下线的时候，我就做了一个临时主页，很简单的几行 HTML 代码。
	  
	  这种临时主页建议放到 Github Pages 或者 Netlify，它们的带宽大，可以应对攻击，而且都支持绑定域名，还能从源码自动构建。

	- HTTP 请求的拦截

	  如果恶意请求有特征，对付起来很简单：直接拦截它就行了。
	  HTTP 请求的特征一般有两种：IP 地址和 User Agent 字段。比如，恶意请求都是从某个 IP 段发出的，那么把这个 IP 段封掉就行了。或者，它们的 User Agent 字段有特征（包含某个特定的词语），那就把带有这个词语的请求拦截。
	  拦截可以在三个层次做。
	  （1）专用硬件
	  Web 服务器的前面可以架设硬件防火墙，专门过滤请求。这种效果最好，但是价格也最贵。
	  （2）本机防火墙
	  操作系统都带有软件防火墙，Linux 服务器一般使用 iptables。比如，拦截 IP 地址1.2.3.4的请求，可以执行下面的命令。
	  
	  $ iptables -A INPUT -s 1.2.3.4 -j DROP
	  iptables 比较复杂，我也不太会用。它对服务器性能有一定影响，也防不住大型攻击。
	  （3）Web 服务器
	  Web 服务器也可以过滤请求。拦截 IP 地址1.2.3.4，nginx 的写法如下。
	  
	  location / {
	    deny 1.2.3.4;
	  }
	  Apache 的写法是在.htaccess文件里面，加上下面一段。
	  
	  <RequireAll>
	      Require all granted
	      Require not ip 1.2.3.4
	  </RequireAll>
	  如果想要更精确的控制（比如自动识别并拦截那些频繁请求的 IP 地址），就要用到 WAF。这里就不详细介绍了，nginx 这方面的设置可以参考这里和这里。
	  Web 服务器的拦截非常消耗性能，尤其是 Apache。稍微大一点的攻击，这种方法就没用了。

	- 带宽扩容

	  上一节的 HTTP 拦截有一个前提，就是请求必须有特征。但是，真正的 DDOS 攻击是没有特征的，它的请求看上去跟正常请求一样，而且来自不同的 IP 地址，所以没法拦截。这就是为什么 DDOS 特别难防的原因。
	  当然，这样的 DDOS 攻击的成本不低，普通的网站不会有这种待遇。不过，真要遇到了该怎么办呢，有没有根本性的防范方法呢？
	  答案很简单，就是设法把这些请求都消化掉。30个人的餐厅来了300人，那就想办法把餐厅扩大（比如临时再租一个门面，并请一些厨师），让300个人都能坐下，那么就不影响正常的用户了。对于网站来说，就是在短时间内急剧扩容，提供几倍或几十倍的带宽，顶住大流量的请求。这就是为什么云服务商可以提供防护产品，因为他们有大量冗余带宽，可以用来消化 DDOS 攻击。
	  一个朋友传授了一个方法，给我留下深刻印象。某云服务商承诺，每个主机保 5G 流量以下的攻击，他们就一口气买了5个。网站架设在其中一个主机上面，但是不暴露给用户，其他主机都是镜像，用来面对用户，DNS 会把访问量均匀分配到这四台镜像服务器。一旦出现攻击，这种架构就可以防住 20G 的流量，如果有更大的攻击，那就买更多的临时主机，不断扩容镜像。

	- CDN

	  CDN 指的是网站的静态内容分发到多个服务器，用户就近访问，提高速度。因此，CDN 也是带宽扩容的一种方法，可以用来防御 DDOS 攻击。
	  网站内容存放在源服务器，CDN 上面是内容的缓存。用户只允许访问 CDN，如果内容不在 CDN 上，CDN 再向源服务器发出请求。这样的话，只要 CDN 够大，就可以抵御很大的攻击。不过，这种方法有一个前提，网站的大部分内容必须可以静态缓存。对于动态内容为主的网站（比如论坛），就要想别的办法，尽量减少用户对动态数据的请求。
	  上一节提到的镜像服务器，本质就是自己搭建一个微型 CDN。各大云服务商提供的高防 IP，背后也是这样做的：网站域名指向高防 IP，它提供一个缓冲层，清洗流量，并对源服务器的内容进行缓存。
	  这里有一个关键点，一旦上了 CDN，千万不要泄露源服务器的 IP 地址，否则攻击者可以绕过 CDN 直接攻击源服务器，前面的努力都白费。搜一下"绕过 CDN 获取真实 IP 地址"，你就会知道国内的黑产行业有多猖獗。

*XMind - Trial Version*