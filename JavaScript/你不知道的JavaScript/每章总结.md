

## [上卷]

### 第一部分 作用域和闭包

#### 第2章 词法作用域 

**词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编泽的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。**

Javascript 中有两个机制可以 “欺骗”词法作用域：eval(…）和with。前者可以对一段包含一个或多个声明的 “代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。

#### 第3章 函数作用域和块作用域

函数是 `Javaseript` 中最常见的作用城单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中 “隐藏”起来，这是有意为之的良好软件的设计原则。但函数不是唯一的作用城单元。块作用域指的是变量和函数不仅可以属于所处的作用城，也可以属于某个代码块（通常指{…}的内部)。

从ES3 开始，`try/catch` 结构在 `catch` 分句中具有块作用域。

在ES6中引人了 `let` 关键字(`var` 关键字的表亲)，用来在任意代码块中声明变量。`if(..){let a = 2;}`会声明一个劫持了if的(..)块的变量，并且将变量添加到这个块中。

有此人认为块作用城不应该完全作为函数作用域的替代方案。两种功能应该同时存在，开发者可以并且也应该根据需要选择使用何种作用域，创造可读、可维护的优良代码。

#### 第4章 提升

我们习惯将var a= 2；看作一个声明，而实际上JavaScript 引1擎并不这么认为。它将var a和a=2当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和的数）都会被“移动”到各自作用域的最顶端，这个过程被称为提升。

声明本身会被提升，而包括函数表达式的赋值在内的操作并不会提升。

要注意避免重复声明，特别是当普通的var声明和函数声明混合在一起的时候，否则会引起很多危险的问题！

> 不过也有说法是存在三个阶段: 声明/创建 初始化 赋值
>
> 1. let 的「创建」过程被提升了，但是初始化没有提升。
> 2. var 的「创建」和「初始化」都被提升了。
> 3. function 的「创建」「初始化」和「赋值」都被提升了。



#### 第5章 作用域闭包

闭包就好像从 JavaScript 中分离出来的一个充满神秘色彩的未开化世界，只有最勇敢的人才能够到达那里。但实际上它只是一个普通且明显的事实，那就是我们在词法作用域的环境下写代码，而其中的函数也是值，可以随意传来传去。

> **当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。**

如果没能认出闭包，也不了解它的工作原理，在使用它的过程甲就很容易犯错，比如在循环中。但同时闭包也是一个非常强大的工具，可以用多种形式来实现**模块**等模式：

模块有两个主要特征：（1）为创建内部作用域而调用了一个包装函数；（2） 包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包 装函数内部作用域的闭包。

现在我们会发现代码中到处都有闭包存在，并且我们能够识别闭包然后用它来做一些有用的事！



### 第二部分 this和对象原型

#### 第2章 this全面解析

[this](/Users/owsl/Desktop/works/MyNotes/JavaScript/this.md)

1.函数是否在new中调用(new绑定)，如果是，那么this绑定的是新创建的对象。

2.函数是否通过call,apply调用，或者使用了bind(即硬绑定)，如果是，那么this绑定的就是指定的对象。

3.函数是否在某个上下文对象中调用(隐式绑定)，如果是的话，this绑定的是那个上下文对象。一般是obj.foo()

4.如果以上都不是，那么使用默认绑定。如果在严格模式下，则绑定到undefined，否则绑定到全局对象。

5.如果把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。

6.如果是箭头函数，箭头函数的this继承的是外层代码块的this。



#### 第三章 对象

虽然`typeof null = object`(因为不同的对象在底层都表示为二进制，在JS中二进制前三位为0的会被判断为object类型，而null的二进制表示是全0)，但是null本身是基本数据类型；

```js
let abj = {
  a:'2'
}
```

属性访问`obj.a` 键值访问`obj["a"]`，对象中属性名永远是字符串，如果使用string(字面量)以外的其他值作为属性名，那它首先会被转换成一个字符串。

**`Object.getOwnPropertyDescriptor()`** 方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）,除了value以外，还包含writable enumerable configurable get set等；

在不访问属性值的情况下判断对象是否存在某一属性: `'a' in obj`或者`obj.hasOwnProperty('a')`,in操作符会检查属性是否在对象以及对象的原型链上，hasOwnProperty只会检查是否在对象中。

enumerable`可枚举`的属性，相当于'可以出现在对象属性的遍历中'，`Object.keys()`会返回一个(对象直接包含的)所有可枚举属性的数组，经验法则是，可枚举属性总是出现在 `for...in` 循环中。

`可迭代`的对象，如果一个对象定义了它的迭代行为，那么它是可迭代的。比如在 `for...of` 循环会首先向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的`next()`来遍历所有返回值。一些内置类型同时是[内置可迭代对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#内置可迭代对象)，并且有默认的迭代行为，比如 [`Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array) 或者 [`Map`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map);要成为**可迭代**对象，一个对象必须实现 `@@iterator` 方法。这意味着对象（或者它[原型链](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)上的某个对象）必须有一个键为 `@@iterator` 的属性，可通过常量[`Symbol.iterator`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator) 访问该属性：

```js
let someString = "hi";                       // String是个内置的可迭代对象
typeof someString[Symbol.iterator];          // "function"
```

手动遍历arr:     功能等同于for of

<img src="https://raw.githubusercontent.com/zhedieya/MyPics/main/typora-img/image-20220810233347975.png" alt="image-20220810233347975" style="zoom:50%;" align="left" />

一些内置的语法结构——比如[`展开语法`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)——其内部实现也使用了同样的迭代协议：

```js
[...someString]                              // ["h", "i"]
```

##### 总结：

许多人都以为“Javascript 中万物都是对象”，这是错误的。对象是6个（或者是7个，取决于你的观点）基础类型之一。对象有包括 function 在内的子类型，不同子类型具有不同的行为，比如内部标签[object Array] 表示这是对象的子类型数组。

对象就是键/值对的集合。可以通过 .propName 或者["propName"] 语法来获取属性值。访问属性时，引擎实际上会调用内部的默认 [[Get]]操作(在设置属性值时是[[Put]]),[[Get]〕操作会检查对象本身是否包含这个属性，如果没找到的话还会查找 [[Prototype]]链。

属性的特性可以通过属性描述符来控制，比如`writable` 和`configurable`。此外，可以使用Object.preventExtensions(..）、Object.seal(..)和object.freeze(..）来设置对象（及其属性）的不可变性级别。

属性不一定包含值-一它们可能是具备getter/setter 的 “访问描述符”。此外，属性可以是可枚举或者不可枚举的，这决定了它们是否会出现在 for..in 循环中。

你可以使用 ES6 的for..of 语法来遍历数据结构（数组、对象，等等）中的值，for..of会寻找内置或者自定义的 `@@iterator` 对象并调用它的 next(）方法来遍历数据值，



#### 第4章 混合对象"类"

由于类是一种设计模式，所以可以用一些方法近似实现类的功能，为了满足对于类设计模式的最普遍需求，JavaScript提供了一些近似类的语法。



#### 第5章 原型

`Object.create()` 方法用于创建一个新对象，使用现有的对象来作为新创建对象的原型（prototype）

使用`for..in`遍历对象时的原理和查找[[Prototype]]链类似，任何可以通过原型链访问到的属性都会被枚举。使用in操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链。

**`instanceof`** **运算符**用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。

**`isPrototypeOf()`** 方法用于测试一个对象是否存在于另一个对象的原型链上。

> `isPrototypeOf()` 与 [`instanceof`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof) 运算符不同。在表达式 "`object instanceof AFunction`"中，`object` 的原型链是针对 `AFunction.prototype` 进行检查的，而不是针对 `AFunction` 本身。

**`Object.getPrototypeOf()`** 方法返回指定对象的原型（内部`[[Prototype]]`属性的值）。

如果要访问对象中并不存在的一个属性，[Get]]操作就会查找对象内部[[Prototype]]关联的对象。这个关联关系实际上定义了一条“原型链”（有点像嵌套的作用域链），在查找属性时会对它进行遍历。

所有普通对象都有内置的 object.prototype，指向原型链的顶端（比如说全局作用域）。如果在原型链中找不到指定的属性就会停止。toString()、valueOf()， 和其他一些通用的功能都存在于 Object.prototype对象上，因此语言中所有的对象都可以使用它们。

关联两个对象最常用的方法是使用 new 关键词进行函数调用，在调用的4个步骤中会创建一个关联其他对象的新对象。

使用 new 调用西数时会把新对象的 .prototype 属性关联到 “其他对象”。带 new的函数调用通常被称为“构造函数调用”，尽管它们实际上和传统面向类语言中的类构造函数不一样。

虽然这些 JavaSoript 机制和传统面向类语言中的“类初始化”和“类继承”很相似，但是Javasoript 中的机制有一个核心区别，那就是不会进行复制，对象之间是通过内部的
[[Prototype ]]链关联的。

出于各种原因，以“继承”结尾的术语（包括“原型继承”）和其他面向对象的术语都无法帮助你理解JavaSript 的兵实机制（不仅仅是限制我们的思维模式）。

相比之下，“委托”是一个更合通的术话，因为对象之间的关系不是复制而是委托，



>2022年9月4日  囫囵吞枣似的读完了上卷。不过有关[类]和[委托]的两章看的很模糊，没什么耐心看完，感觉用处不是很大哇(其实还是自己菜和懒)
>接下来的两卷要看的快点了，不然一直拖着，都忘了看的啥了。



## [下卷]

### 第一部分 类型和语法

